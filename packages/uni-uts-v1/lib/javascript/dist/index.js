'use strict';

var path = require('path');
var fs$1 = require('fs');
var module$1 = require('module');
var pluginutils = require('@rollup/pluginutils');
var safe = require('colors/safe');
var findCacheDir = require('find-cache-dir');
var semver = require('semver');
var sourceMapJs = require('source-map-js');
var codeFrame = require('@babel/code-frame');
var _ = require('lodash');
var fs = require('fs-extra');
var graphlib = require('graphlib');
var objHash = require('object-hash');
var url = require('url');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var ___namespace = /*#__PURE__*/_interopNamespaceDefault(_);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);

/**
 * 仅uts2js需要执行，目前主要用于提前处理vue相关类型文件内容，最终在rollup-plugin-uts内加载文件时执行
 */
function replaceVueTypes(fileName, content) {
    if (!fileName.endsWith('runtime-core.d.ts')) {
        return content;
    }
    /**
     * 替换inject的定义为以下内容
     * type ObjectInjectOptions<I = Data> = {
     *   [K in keyof I]: {
     *     type: PropType<I[K]>;
     *     default: I[K];
     *   }
     * };
     * type InjectToObject<T> = T extends string[] ? {
     *   [K in T[number]]: unknown;
     * } : T extends ObjectInjectOptions<infer I> ? {
     *   [K in keyof I]: I[K];
     * } : never;
     */
    content = content.replace(/type ObjectInjectOptions = Record<([\s\S]+?)>;/, `type ObjectInjectOptions<I = Data> = {
  [K in keyof I]: {
    type: PropType<I[K]>;
    default: I[K];
  }
};`);
    content = content.replace(/type InjectToObject<T([\s\S]+?): never;/, `type InjectToObject<T> = T extends string[] ? {
  [K in T[number]]: unknown;
} : T extends ObjectInjectOptions<infer I> ? {
  [K in keyof I]: I[K];
} : never;`);
    return content;
}

globalThis.__utsHacker__ = {
    ...globalThis.__utsHacker__,
    replaceVueTypes,
};

var IDENTIFIER;
(function (IDENTIFIER) {
    IDENTIFIER["UTSJSONObject"] = "UTSJSONObject";
    IDENTIFIER["JSON"] = "JSON";
    IDENTIFIER["UTS"] = "UTS";
    IDENTIFIER["DEFINE_COMPONENT"] = "defineComponent";
    IDENTIFIER["DEFINE_APP"] = "defineApp";
    IDENTIFIER["VUE"] = "vue";
    IDENTIFIER["GLOBAL_THIS"] = "globalThis";
    IDENTIFIER["UTS_TYPE"] = "UTSType";
    IDENTIFIER["UTS_METADATA"] = "$UTSMetadata$";
    IDENTIFIER["TEMP_UTS_METADATA"] = "$TempUTSMetadata$";
    IDENTIFIER["JSON_FIELD"] = "JSON_FIELD";
})(IDENTIFIER || (IDENTIFIER = {}));
var UTS_CLASS_METADATA_KIND;
(function (UTS_CLASS_METADATA_KIND) {
    UTS_CLASS_METADATA_KIND[UTS_CLASS_METADATA_KIND["CLASS"] = 0] = "CLASS";
    UTS_CLASS_METADATA_KIND[UTS_CLASS_METADATA_KIND["INTERFACE"] = 1] = "INTERFACE";
    UTS_CLASS_METADATA_KIND[UTS_CLASS_METADATA_KIND["TYPE"] = 2] = "TYPE";
})(UTS_CLASS_METADATA_KIND || (UTS_CLASS_METADATA_KIND = {}));

var DiagnosticCategory;
(function (DiagnosticCategory) {
    DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
    DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
    DiagnosticCategory[DiagnosticCategory["Suggestion"] = 2] = "Suggestion";
    DiagnosticCategory[DiagnosticCategory["Message"] = 3] = "Message";
})(DiagnosticCategory || (DiagnosticCategory = {}));

// <auto-generated />
// generated from 'packages/shared/src/diagnosticMessages.json'
function diag(code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated) {
    return { code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated };
}
/** @internal */
const UTSDiagnostics = {
    Type_literal_property_must_have_a_type_annotation: diag(100000, DiagnosticCategory.Error, "Type_literal_property_must_have_a_type_annotation_100000", "Type literal property must have a type annotation."),
    Only_one_extends_heritage_clause_is_allowed_for_interface: diag(100001, DiagnosticCategory.Error, "Only_one_extends_heritage_clause_is_allowed_for_interface_100001", "Only one extends heritage clause is allowed for interface"),
    Variable_declaration_must_have_initializer: diag(100002, DiagnosticCategory.Error, "Variable_declaration_must_have_initializer_100002", "Variable declaration must have initializer."),
    Nested_type_literal_is_not_supported: diag(100003, DiagnosticCategory.Error, "Nested_type_literal_is_not_supported_100003", "Nested type literal is not supported."),
    Invalid_generic_type_which_can_not_be_constructed: diag(100004, DiagnosticCategory.Error, "Invalid_generic_type_which_can_not_be_constructed_100004", "Invalid generic type which can not be constructed."),
};

function normalizePath(id) {
    return id.replace(/\\/g, '/');
}

({
    name: 'uts:' + IDENTIFIER.JSON,
    // @ts-expect-error 内部属性
    importName: IDENTIFIER.JSON,
    scoped: false,
    text: '',
    priority: 100,
});

const UTSHelper = {
    name: 'uts:' + IDENTIFIER.UTS,
    // @ts-expect-error 内部属性
    importName: IDENTIFIER.UTS,
    scoped: false,
    text: '',
    priority: 100,
};
function createUTSHelper(context) {
    context.requestEmitHelper(UTSHelper);
    return context.getEmitHelperFactory().getUnscopedHelperName(IDENTIFIER.UTS);
}

const newUTSJSONObjectHelper = {
    name: 'uts:' + IDENTIFIER.UTSJSONObject,
    // @ts-expect-error 内部属性
    importName: IDENTIFIER.UTS,
    scoped: false,
    text: '',
    priority: 100,
};
function createUTSJSONObjectHelper(context) {
    context.requestEmitHelper(newUTSJSONObjectHelper);
    return context.factory.createIdentifier(IDENTIFIER.UTSJSONObject);
}
function createNewUTSJSONObjectHelper(context, argumentsArray) {
    context.requestEmitHelper(newUTSJSONObjectHelper);
    return context.factory.createNewExpression(context.factory.createIdentifier(IDENTIFIER.UTSJSONObject), 
    /* typeArguments */ undefined, argumentsArray);
}

function createTsUtils(ts, typeChecker, // parse阶段不传
context) {
    function isImportedSymbol(symbol) {
        /**
         * import x from 'xx'
         * import { x } from 'xx'
         */
        return !!(symbol.declarations &&
            symbol.declarations.some((declaration) => {
                return (ts.isImportSpecifier(declaration) ||
                    (ts.isImportClause(declaration) && declaration.name));
            }));
    }
    function getOriginalType(type) {
        // @ts-ignore
        return type?.constraintType?.origin?.type || type;
    }
    function isObjectLiteralType(type) {
        if (!type) {
            return false;
        }
        // @ts-ignore
        const flags = type?.objectFlags;
        if (flags &&
            (flags & ts.ObjectFlags.ObjectLiteral ||
                flags & ts.ObjectFlags.FreshLiteral)) {
            return true;
        }
        const symbol = type.getSymbol();
        if (symbol && symbol.flags & ts.SymbolFlags.ObjectLiteral) {
            return true;
        }
        return false;
    }
    function isPossibleNullType(type) {
        if (!type) {
            return false;
        }
        const nullType = typeChecker.getNullType();
        // @ts-ignore
        return typeChecker.isTypeAssignableTo(nullType, type);
    }
    function isPossiblePromiseNullType(type) {
        if (!type) {
            return false;
        }
        // @ts-ignore
        return isPossibleNullType(typeChecker.getPromisedTypeOfPromise(type));
    }
    function isPossibleUTSJSONObjectType(type, ignoreUnresolved = false) {
        /**
         * 以下三种情况都认为是可能的UTSJSONObject类型，进行转化
         * - 未知类型
         * - UTSJSONObject类型
         * - 联合类型，其中包含UTSJSONObject类型
         */
        if (!type) {
            return !ignoreUnresolved;
        }
        // const orginalType = getOriginalType(type)
        // return orginalType.symbol?.escapedName === IDENTIFIER.UTSJSONObject
        return ((type.isUnion() &&
            type.types.some((type) => getOriginalType(type).symbol?.escapedName ===
                IDENTIFIER.UTSJSONObject)) ||
            getOriginalType(type).symbol?.escapedName === IDENTIFIER.UTSJSONObject);
    }
    function isUnionWithNullType(typeNode) {
        return !!(typeNode &&
            ts.isUnionTypeNode(typeNode) &&
            typeNode.types.some((type) => ts.isLiteralTypeNode(type) &&
                type.literal.kind === ts.SyntaxKind.NullKeyword));
    }
    /**
     * 获取对象字面量方法名节点
     */
    function getMethodNameNodeOfObjectLiteral(node) {
        if (ts.isMethodDeclaration(node)) {
            return node.name;
        }
        const parent = node.parent;
        if (!ts.isPropertyAssignment(parent)) {
            return;
        }
        const propertyName = parent.name;
        return ts.isIdentifier(propertyName) ? propertyName : undefined;
    }
    function createTypeNodeWithNullType(typeNode, withQuestionToken) {
        const factory = context.factory;
        const unionWithNullType = isUnionWithNullType(typeNode);
        let realMemberType = typeNode;
        if (withQuestionToken && !unionWithNullType) {
            // 尝试为memberType添加null类型
            if (ts.isUnionTypeNode(typeNode)) {
                realMemberType = factory.createUnionTypeNode([
                    ...typeNode.types,
                    factory.createLiteralTypeNode(factory.createNull()),
                ]);
            }
            else {
                realMemberType = factory.createUnionTypeNode([
                    typeNode,
                    factory.createLiteralTypeNode(factory.createNull()),
                ]);
            }
        }
        return realMemberType;
    }
    return {
        ts,
        typeChecker,
        context,
        isImportedSymbol,
        isPossibleUTSJSONObjectType,
        isPossibleNullType,
        isPossiblePromiseNullType,
        createTypeNodeWithNullType,
        isUnionWithNullType,
        isObjectLiteralType,
        getMethodNameNodeOfObjectLiteral,
    };
}

function wrapTransformer(ts, ls, transformer, setParentRecursive = false, allowDtsFiles = false) {
    return (context) => {
        const transform = transformer(context);
        return (node) => {
            if (!context.fileName) {
                if (ts.isSourceFile(node)) {
                    context.fileName = node.fileName;
                }
            }
            if (ls.isUTSFile(context.fileName) ||
                (allowDtsFiles && context.fileName.endsWith('.d.ts'))) {
                if (ts.isSourceFile(node) && !node.isUTSFile) {
                    node.isUTSFile = true;
                    if (ls.isVueFile(context.fileName)) {
                        node.isVueFile = true;
                    }
                }
                const updated = transform(node);
                if (updated !== node && setParentRecursive) {
                    // @ts-expect-error 内部方法
                    ts.setParentRecursive(updated, true);
                }
                return updated;
            }
            return node;
        };
    };
}
function initParser(ts, ls, parser, options) {
    // if (options.InterfaceDeclaration) {
    //   ;(parser.InterfaceDeclaration || (parser.InterfaceDeclaration = [])).push(
    //     wrapTransformer(ts, ls, options.InterfaceDeclaration),
    //   )
    // }
    if (options.TypeAliasDeclaration) {
        (parser.TypeAliasDeclaration || (parser.TypeAliasDeclaration = [])).push(
        // TODO allowDtsFiles配置项优化
        wrapTransformer(ts, ls, options.TypeAliasDeclaration, 
        /* setParentRecursive */ true, 
        /* allowDtsFiles */ true));
    }
    if (options.SourceFile) {
        (parser.SourceFile || (parser.SourceFile = [])).push(wrapTransformer(ts, ls, options.SourceFile, true));
    }
}
function parseTransformer(ts, transformers) {
    return (ls) => {
        const parser = {};
        const before = [];
        const after = [];
        const afterDeclarations = [];
        transformers.forEach((creator) => {
            const transformer = creator(ts, ls);
            if (typeof transformer === 'function') {
                before.push(wrapTransformer(ts, ls, transformer));
            }
            else {
                if (transformer.parser) {
                    initParser(ts, ls, parser, transformer.parser);
                }
                if (transformer.before) {
                    before.push(wrapTransformer(ts, ls, transformer.before));
                }
                if (transformer.after) {
                    after.push(wrapTransformer(ts, ls, transformer.after));
                }
                if (transformer.afterDeclarations) {
                    afterDeclarations.push(wrapTransformer(ts, ls, transformer.afterDeclarations));
                }
            }
        });
        return {
            parser,
            before,
            after,
            afterDeclarations,
        };
    };
}

function isSymbolTransformable(tsUtils, symbol) {
    const { ts } = tsUtils;
    const declarations = symbol?.declarations;
    if (declarations?.length !== 1) {
        return false;
    }
    const declaration = declarations[0];
    if (ts.isClassDeclaration(declaration)) {
        const isUTSType = declaration.heritageClauses?.some((heritageClause) => {
            return (heritageClause.token === ts.SyntaxKind.ExtendsKeyword &&
                heritageClause.types.some((type) => {
                    return (isTempUTSTypeNode(tsUtils, type.expression) ||
                        isUTSTypeNode(tsUtils, type.expression));
                }));
        });
        return isUTSType;
    }
    return false;
}
function isNodeTransformable(tsUtils, node) {
    const typeChecker = tsUtils.typeChecker;
    const type = typeChecker.getContextualType(node);
    return !!(type && isTypeTransformable(tsUtils, type));
}
function isTypeTransformable(tsUtils, type) {
    return type.symbol && isSymbolTransformable(tsUtils, type.symbol);
}
function createTempUTSTypeNode(tsUtils) {
    const context = tsUtils.context;
    const factory = context.factory;
    const ts = tsUtils.ts;
    // (glbalThis as any).UTSType
    return factory.createPropertyAccessExpression(factory.createParenthesizedExpression(factory.createAsExpression(factory.createIdentifier(IDENTIFIER.GLOBAL_THIS), factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword))), factory.createIdentifier(IDENTIFIER.UTS_TYPE));
}
function isTempUTSTypeNode(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isPropertyAccessExpression(node)) {
        return false;
    }
    const { expression, name } = node;
    return (ts.isIdentifier(name) &&
        name.escapedText === IDENTIFIER.UTS_TYPE &&
        ts.isParenthesizedExpression(expression) &&
        ts.isAsExpression(expression.expression) &&
        ts.isIdentifier(expression.expression.expression) &&
        expression.expression.expression.escapedText === IDENTIFIER.GLOBAL_THIS);
}
function isUTSTypeClass(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isClassDeclaration(node)) {
        return false;
    }
    const { heritageClauses } = node;
    const parentClass = heritageClauses?.[0]?.types?.[0]?.expression;
    if (parentClass && isTempUTSTypeNode(tsUtils, parentClass)) {
        return true;
    }
    return false;
}
function isUTSTypeNode(tsUtils, node) {
    const ts = tsUtils.ts;
    if (!ts.isPropertyAccessExpression(node)) {
        return false;
    }
    const { expression, name } = node;
    return (ts.isIdentifier(name) &&
        name.escapedText === IDENTIFIER.UTS &&
        ts.isIdentifier(expression) &&
        expression.escapedText === IDENTIFIER.UTS_TYPE);
}
function createRuntimeTypeNode(tsUtils, type) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const unknown = factory.createStringLiteral('Unknown');
    if (tsUtils.isUnionWithNullType(type) && type.types.length === 2) {
        // xxx | null 直接按照 xxx 类型处理，并同时添加optional: true标记
        type = type.types.find((item) => item.kind !== ts.SyntaxKind.NullKeyword);
    }
    // 注意此方法未支持所有typeNode类型，仅支持如下情况
    if (ts.isTypeReferenceNode(type)) {
        const { typeName, typeArguments } = type;
        if (!ts.isIdentifier(typeName)) {
            return unknown;
        }
        const symbol = typeChecker.getSymbolAtLocation(typeName);
        const declaration = symbol?.declarations?.[0];
        if (!declaration || !isUTSTypeClass(tsUtils, declaration)) {
            return unknown;
        }
        if (!typeArguments) {
            return factory.createIdentifier(typeName.escapedText.toString());
        }
        return factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier(typeName.escapedText.toString()),
            factory.createArrayLiteralExpression([
                ...typeArguments.map((typeArgument) => createRuntimeTypeNode(tsUtils, typeArgument)),
            ], false),
        ]);
    }
    else if (ts.isArrayTypeNode(type)) {
        return factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier('Array'),
            factory.createArrayLiteralExpression([createRuntimeTypeNode(tsUtils, type.elementType)], false),
        ]);
    }
    else if (ts.isTypeLiteralNode(type)) {
        context.addBindDiagnostic(ts.createDiagnosticForNode(type, UTSDiagnostics.Nested_type_literal_is_not_supported));
    }
    else if (type.kind === ts.SyntaxKind.NumberKeyword) {
        return factory.createIdentifier('Number');
    }
    else if (type.kind === ts.SyntaxKind.StringKeyword) {
        return factory.createIdentifier('String');
    }
    else if (type.kind === ts.SyntaxKind.BooleanKeyword) {
        return factory.createIdentifier('Boolean');
    }
    else if (type.kind === ts.SyntaxKind.AnyKeyword) {
        return factory.createStringLiteral('Any');
    }
    return unknown;
}
/**
 * class A {
 *   a: number
 *   protected b(){
 *   }
 *   constructor(a: number) {
 *     this.a = a
 *   }
 * }
 *
 * // 错误 Property 'b' is missing in type '{ a: number; }' but required in type 'A'.
 * const a: A = {
 *   a: 1,
 * }
 *
 * // 正确
 * const a = {
 *   a: 1
 * } as A
 */
function createStaticGetUTSMetadataNode(tsUtils, typeParameters, metadata) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    return factory.createMethodDeclaration([factory.createToken(ts.SyntaxKind.StaticKeyword)], undefined, factory.createIdentifier('get' + IDENTIFIER.UTS_METADATA), undefined, undefined, typeParameters
        ? [
            ...typeParameters.map((typeParameter) => {
                return factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier(typeParameter.name.escapedText.toString()), factory.createToken(ts.SyntaxKind.QuestionToken), factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), undefined);
            }),
        ]
        : [], undefined, factory.createBlock([
        factory.createReturnStatement(factory.createAsExpression(metadata, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword))),
    ], true));
}
// class和interface使用此方法，不记录字段名，仅记录类型与继承关系，此方法在parse阶段调用
function createBasicUTSMetadataNode(tsUtils, kind, interfaceNameList) {
    const context = tsUtils.context;
    const factory = context.factory;
    const utsMetadataNodeMembers = [
        factory.createPropertyAssignment(factory.createIdentifier('kind'), factory.createNumericLiteral(kind)),
        factory.createPropertyAssignment(factory.createIdentifier('interfaces'), factory.createArrayLiteralExpression(interfaceNameList, false)),
    ];
    return [
        createStaticGetUTSMetadataNode(tsUtils, undefined, factory.createObjectLiteralExpression(utsMetadataNodeMembers, true)),
    ];
}
// type字面量声明使用此方法，此方法在transform阶段执行
function createTypeUTSMetadataNode(tsUtils, kind, members, typeParameters) {
    const context = tsUtils.context;
    const factory = context.factory;
    // { kind: 0, interfaces: [] }
    const utsMetadataNodeMembers = [
        factory.createPropertyAssignment(factory.createIdentifier('kind'), factory.createNumericLiteral(kind)),
        /**
         * get fields() {
         *   return {
         *     a: {
         *       type: Number,
         *       optional: false,
         *       jsonField: 'a_b',
         *     },
         *   }
         * }
         */
        factory.createGetAccessorDeclaration(undefined, factory.createIdentifier('fields'), [], undefined, factory.createBlock([
            factory.createReturnStatement(factory.createObjectLiteralExpression([
                ...members.map((member) => {
                    let jsonField = '';
                    // ts.getJSDocTags 无法获取member的jsDoc，暂未排查原因，先通过下面的方式绕过
                    // @ts-ignore
                    const jsDoc = (member.jsDoc || []);
                    jsDoc.forEach((jsDocItem) => {
                        const tags = jsDocItem.tags || [];
                        tags.forEach((item) => {
                            if (item.tagName.escapedText === IDENTIFIER.JSON_FIELD &&
                                typeof item.comment === 'string') {
                                const commentLength = item.comment.length;
                                if ((item.comment[0] === "'" &&
                                    item.comment[commentLength - 1] === "'") ||
                                    (item.comment[0] === '"' &&
                                        item.comment[commentLength - 1] === '"')) {
                                    jsonField = item.comment.slice(1, -1);
                                }
                                else {
                                    jsonField = item.comment;
                                }
                            }
                        });
                    });
                    const fieldInfoObjectElements = [
                        factory.createPropertyAssignment(factory.createIdentifier('type'), createRuntimeTypeNode(tsUtils, member.type)),
                        factory.createPropertyAssignment(factory.createIdentifier('optional'), member.questionToken ||
                            tsUtils.isUnionWithNullType(member.type)
                            ? factory.createTrue()
                            : factory.createFalse()),
                    ];
                    if (jsonField) {
                        fieldInfoObjectElements.push(factory.createPropertyAssignment(factory.createIdentifier('jsonField'), factory.createStringLiteral(jsonField)));
                    }
                    return factory.createPropertyAssignment(factory.createIdentifier(member.name.escapedText.toString()), factory.createObjectLiteralExpression(fieldInfoObjectElements));
                }),
            ], true)),
        ], true)),
    ];
    return [
        createStaticGetUTSMetadataNode(tsUtils, typeParameters, factory.createObjectLiteralExpression(utsMetadataNodeMembers, true)),
    ];
}

function addUTSMetadataNodeForClassIfNeeded(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    // 仅为impements添加utsMetadataNode
    const factory = context.factory;
    const heritageClauses = node.heritageClauses;
    if (!heritageClauses) {
        return node;
    }
    const implementsHeritageClauses = heritageClauses.filter((item) => {
        return item.token === ts.SyntaxKind.ImplementsKeyword;
    });
    if (implementsHeritageClauses.length !== 1) {
        return node;
    }
    const types = implementsHeritageClauses[0].types;
    const interfaceNameList = [];
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        if (!type.expression || !ts.isIdentifier(type.expression)) {
            continue;
        }
        const symbol = typeChecker.getSymbolAtLocation(type.expression);
        const declarations = symbol?.declarations || [];
        if (declarations.length !== 1) {
            continue;
        }
        const declaration = declarations[0];
        if (!ts.isClassDeclaration(declaration)) {
            continue;
        }
        interfaceNameList.push(type.expression);
    }
    if (interfaceNameList.length === 0) {
        return node;
    }
    return factory.updateClassDeclaration(node, node.modifiers, node.name, node.typeParameters, node.heritageClauses, [
        ...createBasicUTSMetadataNode(tsUtils, UTS_CLASS_METADATA_KIND.CLASS, interfaceNameList),
        ...node.members,
    ]);
}
const transformClassImplements = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isClassDeclaration(node)) {
                    node = addUTSMetadataNodeForClassIfNeeded(tsUtils, node);
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

globalThis.__utsUniXGlobalProperties__ =
    globalThis.__utsUniXGlobalProperties__ || new Map();
/**
 * .config.
 */
const transformComponentExtraProperty = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                return (sourceFile) => {
                    const sourceFileName = sourceFile.fileName;
                    const globalPropertiesMap = globalThis
                        ?.__utsUniXGlobalProperties__;
                    if (globalPropertiesMap) {
                        for (const [key, value] of globalPropertiesMap) {
                            if (value.file === sourceFileName) {
                                globalPropertiesMap.delete(key);
                            }
                        }
                    }
                    function visitNode(node) {
                        if (ts.isBinaryExpression(node)) {
                            const { left, operatorToken, right } = node;
                            if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {
                                if (ts.isPropertyAccessExpression(left)) {
                                    const { expression: globalPropertiesExpression, name: globalPropertyName, } = left;
                                    if (ts.isPropertyAccessExpression(globalPropertiesExpression)) {
                                        const { expression: appConfigExpression, name: globalPropertiesIdentifier, } = globalPropertiesExpression;
                                        if (globalPropertiesIdentifier.escapedText.toString() ===
                                            'globalProperties' &&
                                            ts.isPropertyAccessExpression(appConfigExpression)) {
                                            const { name: configIdentifier } = appConfigExpression;
                                            if (configIdentifier.escapedText.toString() === 'config') {
                                                globalPropertiesMap.set(globalPropertyName.escapedText.toString(), {
                                                    file: sourceFileName,
                                                    initializerNode: right,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return ts.visitEachChild(node, visitNode, context);
                    }
                    return visitNode(sourceFile);
                };
            },
        },
    };
};

const transformContext = (ts, ls) => {
    function initContext(context, node) {
        if (ts.isSourceFile(node)) {
            if (!context.addBindDiagnostic) {
                context.addBindDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性
                    node.bindDiagnostics.push(diag);
                };
                context.addBindSuggestionDiagnostic = (diag) => {
                    // @ts-expect-error 内部属性
                    if (!node.bindSuggestionDiagnostics) {
                        // @ts-expect-error 内部属性
                        node.bindSuggestionDiagnostics = [];
                    }
                    // @ts-expect-error 内部属性
                    node.bindSuggestionDiagnostics.push(diag);
                };
            }
        }
        return node;
    }
    return {
        before(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        after(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
        afterDeclarations(context) {
            return (node) => {
                return initContext(context, node);
            };
        },
    };
};

/**
 * 1. 将 import xxx from 'xxx.uts' 转换为 import xxx from 'xxx'
 * @param ts
 * @returns
 */
const transformImportDeclaration = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                return (node) => {
                    node.statements.forEach((node) => {
                        if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
                            if (node.moduleSpecifier &&
                                ts.isStringLiteral(node.moduleSpecifier)) {
                                const text = node.moduleSpecifier.text;
                                if (text.endsWith('.uts') || text.endsWith('.ts')) {
                                    node.moduleSpecifier.text = text.replace(/.u?ts$/, '');
                                }
                            }
                        }
                    });
                    return node;
                };
            },
        },
    };
};

// import { UTS_CLASS_METADATA_KIND } from '@uts/shared'
function createUTSJSONObjectFromObjectLiteral(objectLiteral, context) {
    return createNewUTSJSONObjectHelper(context, [objectLiteral]);
}
function generateImportSymbolFromSourceFile(tsUtils, sourceFile, symbol, alias) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    let exportSymbolName = '';
    const symbolDeclarations = symbol?.declarations || [];
    const declarationLength = symbolDeclarations.length;
    if (declarationLength !== 1) {
        return;
    }
    // @ts-expect-error
    const exports = sourceFile.symbol?.exports;
    for (const exportKey of exports.keys()) {
        const exportSymbolDeclarations = exports.get(exportKey).declarations || [];
        if (exportSymbolDeclarations.length !== 1) {
            continue;
        }
        const exportSymbolDeclaration = exportSymbolDeclarations[0];
        let symbolToCheck;
        let exportNodeToCheck;
        if (ts.isClassDeclaration(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration;
        }
        else if (ts.isExportAssignment(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration.expression;
        }
        else if (ts.isExportSpecifier(exportSymbolDeclaration)) {
            exportNodeToCheck = exportSymbolDeclaration.name;
        }
        symbolToCheck =
            exportNodeToCheck &&
                (typeChecker.getContextualType(exportNodeToCheck)
                    ?.symbol ||
                    typeChecker.getTypeAtLocation(exportNodeToCheck)?.symbol);
        if (symbolToCheck === symbol) {
            exportSymbolName = exportKey;
            break;
        }
    }
    if (!exportSymbolName) {
        return;
    }
    const factory = context.factory;
    const aliasIdentifier = factory.createIdentifier(alias);
    if (exportSymbolName === 'default') {
        return factory.createImportDeclaration(undefined, factory.createImportClause(false, aliasIdentifier, undefined), factory.createStringLiteral(sourceFile.fileName), undefined);
    }
    return factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
        factory.createImportSpecifier(false, exportSymbolName !== alias
            ? factory.createIdentifier(exportSymbolName)
            : undefined, aliasIdentifier),
    ])), factory.createStringLiteral(sourceFile.fileName), undefined);
}
// function setSymbolReferenced(symbol: tsTypes.Symbol, referenced: boolean) {
//   // @ts-ignore
//   symbol.links
// }
/**
 * 判断是否为组件data，此方法不能完美判断如下情况，后续再找更佳方案
 *
 * data() {
 *   const a = {a: 1}
 *   return a
 * }
 */
function isComponentData(tsUtils, node) {
    const { ts } = tsUtils;
    const returnExpression = node.parent;
    if (!returnExpression || !ts.isReturnStatement(returnExpression)) {
        return false;
    }
    const containingFunction = returnExpression?.parent?.parent;
    if (!containingFunction || !ts.isMethodDeclaration(containingFunction)) {
        return false;
    }
    const functionName = containingFunction.name;
    if (!functionName ||
        !ts.isIdentifier(functionName) ||
        functionName.escapedText.toString() !== 'data') {
        return false;
    }
    const callExpression = containingFunction?.parent?.parent;
    if (!callExpression || !ts.isCallExpression(callExpression)) {
        return false;
    }
    const defineComponentFunctionName = callExpression.expression;
    if (!defineComponentFunctionName ||
        !ts.isIdentifier(defineComponentFunctionName) ||
        defineComponentFunctionName.escapedText.toString() !== 'defineComponent') {
        return false;
    }
    return true;
}
function transformObjectLiteralExpression(tsUtils, node, symbolAutoImportMap) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    const factory = context.factory;
    if ((node.flags & ts.NodeFlags.Synthesized) /* Synthesized */ ===
        ts.NodeFlags.Synthesized) {
        // 跳过所有非用户代码
        return;
    }
    if (node.parent && ts.isAsExpression(node.parent)) {
        return;
    }
    if (isComponentData(tsUtils, node)) {
        return;
    }
    // uts2js时main.uts的createApp方法返回值不予转化类型，uts2kotlin时转化为对应的类型
    if (process.env.UNI_INPUT_DIR &&
        normalizePath(path__namespace.resolve(process.env.UNI_INPUT_DIR, 'main.uts')) ===
            normalizePath(node.getSourceFile().fileName) &&
        node.parent &&
        ts.isReturnStatement(node.parent)) {
        const containingFunction = node?.parent?.parent?.parent;
        if (containingFunction &&
            ts.isFunctionDeclaration(containingFunction) &&
            containingFunction.name &&
            ts.isIdentifier(containingFunction.name) &&
            containingFunction.name.escapedText === 'createApp') {
            return;
        }
    }
    /**
     * getContextualType内部逻辑非常复杂
     * 目前遇到的问题：页面data内包含对象字面量，onLoad内包含interface，如果先在before阶段转化interface则会导致上层所有节点被修改丢失symbol。导致getContextualType内部报错。
     * 暂时将ObjectLiteral添加as或者转为UTSJSONObject的逻辑移至最早的before内执行
     *
     * 后续可能的解决方案：所有的transformer内仅做标记不进行before阶段转化，最后添加一个读取标记用于生成最终语法树的transformer。
     */
    const contextualType = typeChecker.getContextualType(node);
    if (contextualType === typeChecker.getAnyType() ||
        tsUtils.isObjectLiteralType(contextualType) ||
        tsUtils.isPossibleUTSJSONObjectType(contextualType)) {
        return createUTSJSONObjectFromObjectLiteral(node, context);
    }
    /**
     * 为未声明类型的ObjectLiteral添加as
     */
    const symbol = contextualType.symbol;
    const className = symbol?.escapedName;
    if (!className || !isTypeTransformable(tsUtils, contextualType)) {
        return;
    }
    /**
     * 判断contextualType在当前作用域的可访问性
     * - type声明在同一个文件的可访问位置，无需自动引入即可直接使用
     * - type声明由其他文件导出，需要自动引入
     * - 其他情况不予转化并给出告警？
     */
    // @ts-expect-error 内部方法
    const symbolAccessibilityResult = typeChecker.isSymbolAccessible(symbol, node, ts.SymbolFlags.Class, true);
    if (symbolAccessibilityResult.accessibility !==
        // @ts-expect-error 内部属性
        ts.SymbolAccessibility.Accessible) {
        // symbol不可通过当前作用域访问，也无法自动引入，不予转化，不给出警告
        return;
    }
    // @ts-expect-error 内部方法
    const accessibleSymbolChain = typeChecker.getAccessibleSymbolChain(symbol, node, symbol.flags, false);
    let typeName;
    if (accessibleSymbolChain && accessibleSymbolChain.length > 0) {
        // symbol可通过当前作用域访问，无需自动引入
        typeName = typeChecker.symbolToEntityName(symbol, ts.SymbolFlags.Class, node, undefined);
    }
    else {
        // symbol不可通过当前作用域访问，但是需要自动引入
        const symbolDeclarations = symbol.declarations;
        if (!symbolDeclarations || symbolDeclarations.length !== 1) {
            return;
        }
        const symbolDeclaration = symbolDeclarations[0];
        const symbolDeclarationSourceFile = symbolDeclaration.getSourceFile();
        const sourceFile = node.getSourceFile();
        if (symbolDeclarationSourceFile === sourceFile) {
            // 正常情况下不应进入此条件判断
            return;
        }
        let typeNameStr;
        let importDeclaration;
        if (symbolAutoImportMap.has(symbol)) {
            const cache = symbolAutoImportMap.get(symbol);
            typeNameStr = cache.alias;
            importDeclaration = cache.importDeclaration;
        }
        else {
            const originalTypeNameStr = symbol.escapedName;
            // @ts-ignore
            typeNameStr = ts.getUniqueName(originalTypeNameStr, sourceFile);
            importDeclaration = generateImportSymbolFromSourceFile(tsUtils, symbolDeclarationSourceFile, symbol, typeNameStr);
            if (!importDeclaration) {
                return;
            }
            symbolAutoImportMap.set(symbol, {
                symbol,
                alias: typeNameStr,
                importDeclaration,
            });
        }
        typeName = factory.createIdentifier(typeNameStr);
    }
    const asExpression = factory.createAsExpression(node, factory.createTypeReferenceNode(typeName, undefined));
    return asExpression;
}
const transformObjectLiteral = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const symbolAutoImportMap = new Map();
            const visitor = (node) => {
                const orginalNode = node;
                // 先子后父解决对象嵌套
                node = ts.visitEachChild(node, visitor, context);
                if (orginalNode !== node) {
                    ts.setOriginalNode(node, orginalNode);
                    ts.setTextRange(node, orginalNode);
                    // @ts-ignore
                    node.parent = orginalNode.parent;
                }
                if (ts.isObjectLiteralExpression(node)) {
                    node =
                        transformObjectLiteralExpression(tsUtils, node, symbolAutoImportMap) || node;
                }
                return node;
            };
            return (node) => {
                const sourceFile = ts.visitNode(node, visitor);
                const importDeclarationList = [];
                for (const cache of symbolAutoImportMap.values()) {
                    importDeclarationList.push(cache.importDeclaration);
                    // @ts-expect-error 内部属性
                    node.locals.set(cache.alias, cache.symbol);
                }
                return context.factory.updateSourceFile(sourceFile, [...importDeclarationList, ...sourceFile.statements], sourceFile.isDeclarationFile, sourceFile.referencedFiles, sourceFile.typeReferenceDirectives, sourceFile.hasNoDefaultLib, sourceFile.libReferenceDirectives);
            };
        },
    };
};

function createInterfaceClassDeclaration(tsUtils, modifiers = [], name, typeParameters, heritageClauses, members) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    function addAbstract(modifiers) {
        return [
            ...(modifiers || []),
            factory.createToken(ts.SyntaxKind.AbstractKeyword),
        ];
    }
    const extendsIdentifierList = [];
    if (heritageClauses &&
        (heritageClauses.length > 1 ||
            (heritageClauses.length === 1 &&
                heritageClauses.some((item) => item.token !== ts.SyntaxKind.ExtendsKeyword)))) {
        context.addBindDiagnostic(ts.createDiagnosticForNode(heritageClauses[0].parent, UTSDiagnostics.Only_one_extends_heritage_clause_is_allowed_for_interface));
        return;
    }
    const heritageClausesTypes = heritageClauses && heritageClauses.length > 0
        ? [...heritageClauses[0].types]
        : [];
    for (let i = 0; i < heritageClausesTypes.length; i++) {
        const type = heritageClausesTypes[i];
        if (ts.isIdentifier(type.expression)) {
            extendsIdentifierList.push(type.expression);
        }
    }
    const classMembers = members.map((member) => {
        const { modifiers = [], name: memberName, questionToken, type: memberType, } = member;
        const realMemberType = memberType &&
            tsUtils.createTypeNodeWithNullType(memberType, !!questionToken);
        return factory.createPropertyDeclaration(addAbstract([...modifiers]), memberName, questionToken, realMemberType, 
        /*initializer*/ undefined);
    });
    const utsMetadataNodes = createBasicUTSMetadataNode(tsUtils, UTS_CLASS_METADATA_KIND.INTERFACE, extendsIdentifierList);
    return factory.createClassDeclaration(addAbstract(modifiers), name, typeParameters?.length ? typeParameters : undefined, undefined, [...utsMetadataNodes, ...classMembers]);
}
function createTypeClassDeclaration(tsUtils, modifiers, name, typeParameters, members) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const typeLiteralPropertyDiagnostic = UTSDiagnostics.Type_literal_property_must_have_a_type_annotation;
    const optionsTypeMembers = [];
    const classMembers = !members
        ? []
        : members.map((member) => {
            if (!ts.isPropertySignature(member)) {
                context.addBindDiagnostic(ts.createDiagnosticForNode(member, typeLiteralPropertyDiagnostic));
            }
            const { modifiers, name: memberName, questionToken, type: memberType, } = member;
            const realMemberType = memberType &&
                tsUtils.createTypeNodeWithNullType(memberType, !!questionToken);
            optionsTypeMembers.push(factory.createPropertySignature(
            /*modifiers*/ undefined, memberName, questionToken, realMemberType));
            return factory.createPropertyDeclaration(modifiers, memberName, questionToken, realMemberType, 
            /*initializer*/ undefined);
        });
    const optionsType = factory.createTypeLiteralNode(optionsTypeMembers);
    const generatedMembers = [];
    // [key: string] : any
    const indexSignature = factory.createIndexSignature(undefined, [
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('key'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
    ], factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
    const constructorNode = factory.createConstructorDeclaration(undefined, [
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('options'), undefined, optionsType, undefined),
    ], factory.createBlock([
        factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), undefined, [])),
        ...(members || []).map((item) => {
            const nameStr = item.name.escapedText.toString();
            return factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(nameStr)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createPropertyAccessExpression(factory.createIdentifier('options'), factory.createIdentifier(nameStr))));
        }),
    ], true));
    generatedMembers.push(indexSignature, ...classMembers, constructorNode);
    const classDeclaration = factory.createClassDeclaration(modifiers, name, typeParameters?.length ? typeParameters : undefined, [
        factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
            factory.createExpressionWithTypeArguments(createTempUTSTypeNode(tsUtils), undefined),
        ]),
    ], generatedMembers);
    return classDeclaration;
}
function transformTypeClass(tsUtils, node) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    const { modifiers, name, typeParameters, heritageClauses, members } = node;
    const properties = members.filter((item) => ts.isPropertyDeclaration(item));
    /**
     * static get$UTSMetadata() {}
     */
    const utsMetadataNode = createTypeUTSMetadataNode(tsUtils, UTS_CLASS_METADATA_KIND.TYPE, properties, typeParameters ? [...typeParameters] : []);
    const indexSignature = members.find((item) => ts.isIndexSignatureDeclaration(item));
    const originalConstructorNode = members.find((item) => ts.isConstructorDeclaration(item));
    const { parameters } = originalConstructorNode;
    const constructorParameters = [
        ...parameters,
        factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('metadata'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier(name.escapedText), factory.createIdentifier('get' + IDENTIFIER.UTS_METADATA)), undefined, [])),
        factory.createParameterDeclaration(
        /*modifiers*/ undefined, 
        /*dotDotDotToken*/ undefined, factory.createIdentifier('isJSONParse'), 
        /*questionToken*/ undefined, factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword), 
        /*initializer*/ factory.createFalse()),
    ];
    const tempPropsName = '__props__';
    const constructorNode = factory.createConstructorDeclaration(
    /*modifiers*/ undefined, constructorParameters, factory.createBlock([
        // super()
        factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), undefined, [])),
        /**
         * const props = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse) 不可在parse阶段使用改为下面的用法
         * this.__props__ = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse)
         * delete this.__props__
         */
        // this.__props__ = (globalThis as any).UTSType.initProps(options, metadata, isJSONParse)
        factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createCallExpression(factory.createPropertyAccessExpression(createTempUTSTypeNode(tsUtils), factory.createIdentifier('initProps')), undefined, [
            factory.createIdentifier('options'),
            factory.createIdentifier('metadata'),
            factory.createIdentifier('isJSONParse'),
        ]))),
        // this.a = this.__props__.a
        ...properties.map((member) => {
            const { name: memberName } = member;
            const memberNameText = memberName
                .escapedText;
            return factory.createExpressionStatement(factory.createBinaryExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(memberNameText)), factory.createToken(ts.SyntaxKind.EqualsToken), factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)), factory.createIdentifier(memberNameText))));
        }),
        // delete this.__props__
        factory.createExpressionStatement(factory.createDeleteExpression(factory.createPropertyAccessExpression(factory.createThis(), factory.createIdentifier(tempPropsName)))),
    ], 
    /*multiLine*/ true));
    return factory.updateClassDeclaration(node, modifiers, name, typeParameters, heritageClauses, [indexSignature, ...properties, ...utsMetadataNode, constructorNode]);
}
/**
 * 处理继承关系。如果class实现自interface，对应的实例应能通过instanceof判断为interface实例
 * class extends -> class(abstract + not abstract) 不保存interfaces信息
 * class implements -> interface + abstract class 保存interfaces信息，在此处处理
 * interface extends -> interface + class(abstract + not abstract) 保存interfaces信息，在transformTypeAndInterface内处理
 * interface implements -> ×
 *
 * instanceof -> UTS.isInstanceOf
 *
 * 额外注意的点
 * - class声明可以嵌套
 * - 不再支持interface重复声明自动合并，需要抛出错误
 */
const transformTypeAndInterface = (ts, ls) => {
    return {
        parser: {
            TypeAliasDeclaration(context) {
                return function (node) {
                    const factory = context.factory;
                    const { modifiers = [], name, typeParameters = [], type } = node;
                    if (ts.isTypeLiteralNode(type)) {
                        node = factory.updateTypeAliasDeclaration(node, modifiers, name, typeParameters, factory.updateTypeLiteralNode(type, factory.createNodeArray([
                            factory.createIndexSignature(undefined, [
                                factory.createParameterDeclaration(undefined, undefined, factory.createIdentifier('key'), undefined, factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
                            ], factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)),
                            ...type.members,
                        ])));
                    }
                    return node;
                };
            },
            SourceFile(context) {
                const tsUtils = createTsUtils(ts, undefined, context);
                // let hasTypeDeclaration = false
                const visitor = (node) => {
                    const orginalNode = node;
                    if (ts.isTypeAliasDeclaration(node) &&
                        ts.isTypeLiteralNode(node.type)) {
                        const { modifiers = [], name, typeParameters = [], type } = node;
                        const members = type.members;
                        const classDeclaration = createTypeClassDeclaration(tsUtils, [...modifiers], name, [...typeParameters], [
                            ...members.filter((item) => ts.isPropertySignature(item)),
                        ]);
                        if (classDeclaration) {
                            // hasTypeDeclaration = true
                            node = classDeclaration;
                        }
                    }
                    else if (ts.isInterfaceDeclaration(node)) {
                        const { modifiers = [], name, typeParameters = [], members, heritageClauses = [], } = node;
                        const classDeclaration = createInterfaceClassDeclaration(tsUtils, [...modifiers], name, [...typeParameters], [...heritageClauses], [
                            ...members.filter((item) => ts.isPropertySignature(item)),
                        ]);
                        node = classDeclaration || node;
                    }
                    node = ts.visitEachChild(node, visitor, context);
                    if (node !== orginalNode) {
                        // 处理pos、end防止出现`start < 0`报错
                        ts.setTextRange(node, orginalNode);
                    }
                    return node;
                };
                return (node) => {
                    return ts.visitNode(node, visitor);
                };
            },
        },
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const factory = context.factory;
            const visitor = (node) => {
                if (ts.isPropertyAccessExpression(node) &&
                    isTempUTSTypeNode(tsUtils, node)) {
                    /**
                     * parse阶段不能访问createUTSHelper（即使在context上挂上相关方法也不行），用globalThis占位，在此处替换
                     */
                    node = factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier(IDENTIFIER.UTS_TYPE));
                }
                else if (ts.isClassDeclaration(node)) {
                    const { heritageClauses } = node;
                    const parentClass = heritageClauses?.[0]?.types?.[0]?.expression;
                    if (parentClass && isTempUTSTypeNode(tsUtils, parentClass)) {
                        node = transformTypeClass(tsUtils, node);
                    }
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};
/**
 * TODO
 * - 将子作用域内的type声明提升到最外层，以便转化对象字面量时能引用到
 * - interface、type生成的class继承自uts内置类
 */

function componentPublicInstancePropertyAccessFallback(ts, typeChecker, node, left, leftType, right) {
    if (!ts.isPropertyAccessExpression(node) ||
        !ts.isExpression(left) ||
        !ts.isIdentifier(right)) {
        return;
    }
    const leftTypeAliasSymbolName = leftType.aliasSymbol?.escapedName.toString();
    if (leftTypeAliasSymbolName !== 'ComponentPublicInstance' &&
        leftTypeAliasSymbolName !== 'CreateComponentPublicInstance') {
        return;
    }
    const propertyName = right.escapedText.toString();
    const globalPropertiesMap = globalThis?.__utsUniXGlobalProperties__;
    if (globalPropertiesMap && globalPropertiesMap.has(propertyName)) {
        const { initializerNode } = globalPropertiesMap.get(propertyName);
        const type = typeChecker.getTypeAtLocation(initializerNode);
        if (type.isNumberLiteral()) {
            return typeChecker.getNumberType();
        }
        else if (type.isStringLiteral()) {
            return typeChecker.getStringType();
        }
        else if (type.flags & ts.TypeFlags.BooleanLiteral) {
            return typeChecker.getBooleanType();
        }
        return type;
    }
}

function isRelatedTo(ts, typeChecker, source, target) {
    const tsUtils = createTsUtils(ts, typeChecker, undefined);
    const nullType = typeChecker.getNullType();
    const undefinedType = typeChecker.getUndefinedType();
    const voidType = typeChecker.getVoidType();
    const anyType = typeChecker.getAnyType();
    function isUndefinedType(type) {
        return type === undefinedType || type === voidType;
    }
    if (tsUtils.isObjectLiteralType(source) &&
        tsUtils.isPossibleUTSJSONObjectType(target)) {
        /**
         * ObjectLiteral可以赋给UTSJSONObject
         */
        return true;
    }
    else if ((isUndefinedType(source) && target === nullType) ||
        (source === nullType && isUndefinedType(target))) {
        /**
         * undefined可以赋给null
         * 为处理函数返回值类型为undefined的情况
         * function test(): number | null {
         *   return
         * }
         * TODO: 寻找更优解决方案
         */
        return true;
    }
    else if (((source === nullType || isUndefinedType(source)) && target === anyType) ||
        ((target === nullType || isUndefinedType(target)) && source === anyType)) {
        // null | undefined 均不可赋给 any
        return false;
    }
}

function isTypeRelatedTo(ts, typeChecker, source, target) {
    return isRelatedTo(ts, typeChecker, source, target);
}

globalThis.__utsHacker__ = {
    ...globalThis.__utsHacker__,
    isTypeRelatedTo,
    isRelatedTo,
    componentPublicInstancePropertyAccessFallback,
    isUtsCompiler: true,
    hijackAnyNullUnionType: true,
    ignoreInstanceofLeftType: true,
    ignoreAllDebugFail: true,
};

/**
 * 1. 将 export default {} 转换为 export default defineComponent({})
 * > 理论上该逻辑放在预处理环节实现也是可以的，编译器本身也要实现自动导入vue的相关方法，稍后评估吧
 * @param ts
 * @returns
 */
const transformVueDefineComponent = (ts) => {
    return {
        parser: {
            SourceFile(context) {
                const { factory } = context;
                let isAppUvue = false;
                const visitor = (node) => {
                    // 仅 SourceFile 需要遍历子节点，其他不需要，减少遍历流程
                    if (ts.isSourceFile(node)) {
                        return ts.visitEachChild(node, visitor, context);
                    }
                    // 简单判断 export default {}，暂不支持其他方式
                    if (ts.isExportAssignment(node) &&
                        ts.isObjectLiteralExpression(node.expression)) {
                        return factory.updateExportAssignment(node, node.modifiers, factory.createCallExpression(factory.createIdentifier(isAppUvue
                            ? IDENTIFIER.DEFINE_APP
                            : IDENTIFIER.DEFINE_COMPONENT), undefined, [node.expression]));
                    }
                    return node;
                };
                return (node) => {
                    if (!node.isVueFile) {
                        return node;
                    }
                    // 判断是否是App.vue  App.uvue?import&vue&type=script&lang.uts
                    if (path__namespace.basename(node.fileName).split('?')[0].toLowerCase() ===
                        'app.uvue') {
                        isAppUvue = true;
                    }
                    const sourceFile = ts.visitNode(node, visitor);
                    if (sourceFile !== node) {
                        /**
                         * 添加 import { defineComponent } from 'vue'
                         * App.uvue添加 import { defineApp } from 'vue'
                         */
                        return factory.updateSourceFile(sourceFile, [
                            factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                                factory.createImportSpecifier(false, undefined, factory.createIdentifier(isAppUvue
                                    ? IDENTIFIER.DEFINE_APP
                                    : IDENTIFIER.DEFINE_COMPONENT)),
                            ])), factory.createStringLiteral(IDENTIFIER.VUE)),
                            ...sourceFile.statements,
                        ]);
                    }
                    return sourceFile;
                };
            },
        },
        before(context) {
            // 将App.uvue内的defineApp重置为defineComponent
            const { factory } = context;
            const visitor = (node) => {
                // 仅 SourceFile 需要遍历子节点，其他不需要，减少遍历流程
                if (ts.isSourceFile(node)) {
                    return ts.visitEachChild(node, visitor, context);
                }
                // 简单判断 export default {}，暂不支持其他方式
                if (ts.isExportAssignment(node) &&
                    ts.isCallExpression(node.expression)) {
                    return factory.updateExportAssignment(node, node.modifiers, factory.createCallExpression(factory.createIdentifier(IDENTIFIER.DEFINE_COMPONENT), undefined, node.expression.arguments));
                }
                else if (ts.isImportDeclaration(node)) {
                    // 删除 import { defineComponent } from 'vue'
                    if (node.moduleSpecifier &&
                        ts.isStringLiteral(node.moduleSpecifier) &&
                        node.moduleSpecifier.text === IDENTIFIER.VUE &&
                        node.importClause &&
                        ts.isImportClause(node.importClause) &&
                        node.importClause.namedBindings &&
                        ts.isNamedImports(node.importClause.namedBindings) &&
                        node.importClause.namedBindings.elements.some((element) => element.name.text === IDENTIFIER.DEFINE_APP)) {
                        return factory.updateImportDeclaration(node, node.modifiers, factory.updateImportClause(node.importClause, false, undefined, factory.createNamedImports(node.importClause.namedBindings.elements.filter((element) => element.name.text !== IDENTIFIER.DEFINE_APP))), node.moduleSpecifier, node.assertClause);
                    }
                }
                return node;
            };
            return (node) => {
                if (!node.isVueFile) {
                    return node;
                }
                // 判断是否是App.vue  App.uvue?import&vue&type=script&lang.uts
                if (path__namespace.basename(node.fileName).split('?')[0].toLowerCase() ===
                    'app.uvue') {
                    node = ts.visitNode(node, visitor);
                }
                return node;
            };
        },
    };
};

const lifeCycleMap = new Map();
// App and Page
lifeCycleMap.set('onShow', false);
lifeCycleMap.set('onHide', false);
// App
lifeCycleMap.set('onAppShow', true); // true 表示有参数
lifeCycleMap.set('onLaunch', true);
lifeCycleMap.set('onError', true);
lifeCycleMap.set('onThemeChange', true);
lifeCycleMap.set('onKeyboardHeightChange', true);
lifeCycleMap.set('onPageNotFound', true);
lifeCycleMap.set('onUnhandledRejection', true);
lifeCycleMap.set('onLastPageBackPress', false);
lifeCycleMap.set('onExit', false);
// Page
lifeCycleMap.set('onLoad', true);
lifeCycleMap.set('onShow', true); // 页面onShow无参数、App onShow有参数，这里都按照有参数处理
lifeCycleMap.set('onReady', false);
lifeCycleMap.set('onUnload', false);
lifeCycleMap.set('onResize', true);
lifeCycleMap.set('onBackPress', true);
lifeCycleMap.set('onPageScroll', true);
lifeCycleMap.set('onTabItemTap', true);
lifeCycleMap.set('onReachBottom', false);
lifeCycleMap.set('onPullDownRefresh', false);
// Vue
lifeCycleMap.set('beforeCreate', false);
lifeCycleMap.set('created', false);
lifeCycleMap.set('beforeMount', false);
lifeCycleMap.set('mounted', false);
lifeCycleMap.set('beforeUpdate', false);
lifeCycleMap.set('updated', false);
lifeCycleMap.set('beforeUnmount', false);
lifeCycleMap.set('unmounted', false);
/**
 * defineComponent({
 *   onLoad(options) {},
 *   onShow: () => {},
 *   onLaunch: function (){},
 * })
 */
const transformLifeCycleOptions = (ts, ls) => {
    return {
        parser: {
            SourceFile(context) {
                const factory = context.factory;
                const tsUtils = createTsUtils(ts, undefined, context);
                const visitor = (node) => {
                    if (ts.isParameter(node) && !node.type && !node.dotDotDotToken) {
                        const methodNode = node.parent;
                        if (methodNode &&
                            (ts.isMethodDeclaration(methodNode) ||
                                ts.isArrowFunction(methodNode) ||
                                ts.isFunctionExpression(methodNode)) &&
                            methodNode.parameters.indexOf(node) === 0) {
                            const methodNameNode = tsUtils.getMethodNameNodeOfObjectLiteral(methodNode);
                            if (methodNameNode && ts.isIdentifier(methodNameNode)) {
                                const methodName = methodNameNode.escapedText.toString();
                                if (lifeCycleMap.get(methodName) === true) {
                                    const callExpressionNode = methodNameNode?.parent?.parent?.parent;
                                    if (callExpressionNode &&
                                        ts.isCallExpression(callExpressionNode)) {
                                        const callExpressionNameNode = callExpressionNode.expression;
                                        if (ts.isIdentifier(callExpressionNameNode) &&
                                            (callExpressionNameNode.escapedText.toString() ===
                                                IDENTIFIER.DEFINE_APP ||
                                                callExpressionNameNode.escapedText.toString() ===
                                                    IDENTIFIER.DEFINE_COMPONENT)) {
                                            return factory.updateParameterDeclaration(node, node.modifiers, node.dotDotDotToken, node.name, node.questionToken, factory.createTypeReferenceNode(factory.createIdentifier(methodName.replace(/^(\w)/, (str) => str.toUpperCase()) + 'Options'), undefined), node.initializer);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return ts.visitEachChild(node, visitor, context);
                };
                return (node) => {
                    if (!node.isVueFile) {
                        return node;
                    }
                    return ts.visitEachChild(node, visitor, context);
                };
            },
        },
    };
};

/**
 * module M {
 *     export module E {
 *         export type C = {
 *             a: number
 *         }
 *         export class D { }
 *     }
 * }
 * const a = {
 *     a: 1
 * } as M.E.C
 * new M.E.D()
 */
function transformQualifiedNameToPropertyAccessExpression(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    return factory.createPropertyAccessExpression(ts.isQualifiedName(node.left)
        ? transformQualifiedNameToPropertyAccessExpression(tsUtils, node.left)
        : node.left, node.right);
}
function createNewExpressionFromObjectLiteral(tsUtils, objectLiteral, className) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const factory = context.factory;
    const classExpression = ts.isQualifiedName(className)
        ? transformQualifiedNameToPropertyAccessExpression(tsUtils, className)
        : factory.createIdentifier(className.escapedText.toString());
    return factory.createNewExpression(classExpression, undefined, [
        objectLiteral,
    ]);
}
function transformAsExpression(tsUtils, node) {
    const { ts } = tsUtils;
    const context = tsUtils.context;
    const typeChecker = tsUtils.typeChecker;
    const factory = context.factory;
    const { type, expression } = node;
    const symbol = typeChecker.getContextualType(expression)?.symbol;
    if (symbol && symbol.escapedName === 'UTSJSONObject') {
        return factory.createNewExpression(factory.createIdentifier('UTSJSONObject'), undefined, [expression]);
    }
    if (type &&
        isNodeTransformable(tsUtils, expression) &&
        ts.isObjectLiteralExpression(expression)) {
        if (!symbol) {
            return;
        }
        return createNewExpressionFromObjectLiteral(tsUtils, expression, type.typeName);
    }
}
const transformTypedObjectLiteral = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isAsExpression(node)) {
                    node = transformAsExpression(tsUtils, node) || node;
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

function parseVariableDeclaration(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    // node.type 包含 null
    if (!node.initializer &&
        node.pos > 0 &&
        tsUtils.isPossibleNullType(typeChecker.getTypeAtLocation(node))) {
        return factory.updateVariableDeclaration(node, node.name, node.exclamationToken, node.type, factory.createNull());
    }
    return node;
}
function parseParameter(tsUtils, node) {
    const { modifiers, dotDotDotToken, name, questionToken, type, initializer } = node;
    if (node.pos < 0 || initializer || dotDotDotToken) {
        return node;
    }
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    if (questionToken ||
        tsUtils.isPossibleNullType(typeChecker.getTypeAtLocation(node))) {
        return factory.updateParameterDeclaration(node, modifiers, dotDotDotToken, name, questionToken, type && tsUtils.createTypeNodeWithNullType(type, true), initializer || factory.createNull());
    }
    return node;
}
/**
 * 开发者自行指定返回值为为null或包含null时，将`return`转化为`return null`
 * 未指定返回类型时，将`return`转化为`return null`
 *
 * TODO: 返回值类型指定为`Promise<null>`时，需要将`return`转化为`return Promise.resolve(null)`
 */
function parseFunctionLikeDeclaration(tsUtils, node) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const { modifiers, type } = node;
    const isAsync = modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.AsyncKeyword);
    let returnNullType = false;
    let returnPromiseNullType = false;
    if (type) {
        const returnType = typeChecker
            .getSignatureFromDeclaration(node)
            ?.getReturnType();
        if (returnType) {
            returnNullType = tsUtils.isPossibleNullType(returnType);
            returnPromiseNullType = tsUtils.isPossiblePromiseNullType(returnType);
            if (!returnNullType && !returnPromiseNullType) {
                return node;
            }
        }
    }
    function findReturnStatement(node) {
        if (ts.isFunctionLike(node)) {
            return node;
        }
        else if (ts.isReturnStatement(node)) {
            if (!node.expression) {
                return factory.updateReturnStatement(node, isAsync || returnPromiseNullType
                    ? factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier('Promise'), factory.createIdentifier('resolve')), undefined, [factory.createNull()])
                    : factory.createNull());
            }
        }
        return ts.visitEachChild(node, findReturnStatement, context);
    }
    return ts.visitEachChild(node, findReturnStatement, context);
}
const transformUndefinedToNull = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isVariableDeclaration(node) &&
                    !node.initializer &&
                    (!node.parent || !ts.isCatchClause(node.parent))) {
                    // 为未初始化的变量声明增加默认值，属性声明在transformTypeAndInterface内处理
                    node = parseVariableDeclaration(tsUtils, node);
                }
                else if (ts.isParameter(node)) {
                    // 为可选参数增加默认值
                    node = parseParameter(tsUtils, node);
                }
                else if (ts.isFunctionDeclaration(node) ||
                    ts.isMethodDeclaration(node) ||
                    ts.isArrowFunction(node) ||
                    ts.isFunctionExpression(node) ||
                    ts.isGetAccessorDeclaration(node)) {
                    // 为函数声明增加默认值
                    node = parseFunctionLikeDeclaration(tsUtils, node);
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

// function isJsNativeType(symbol: tsTypes.Symbol): boolean {
//   if (!symbol) return false
//   const declarations = symbol.getDeclarations()
//   if (!declarations) return false
//   for (const declaration of declarations) {
//     if (
//       declaration.getSourceFile().isDeclarationFile &&
//       /lib\..*\.d\.ts/i.test(declaration.getSourceFile().fileName)
//     ) {
//       return true
//     }
//   }
//   return false
// }
function transformJSON(tsUtils) {
    const context = tsUtils.context;
    const factory = context.factory;
    createUTSHelper(context);
    return factory.createPropertyAccessExpression(factory.createIdentifier(IDENTIFIER.UTS), factory.createIdentifier(IDENTIFIER.JSON));
}
function transformInstanceof(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    createUTSHelper(context);
    return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier(IDENTIFIER.UTS), factory.createIdentifier('isInstanceOf')), undefined, [node.left, node.right]);
}
const JS_RUNTIME_CALL_EXPRESSION_MAP = {
    Array_pop: 'arrayPop',
    Array_shift: 'arrayShift',
    Array_find: 'arrayFind',
    Array_findLast: 'arrayFindLast',
    Array_at: 'arrayAt',
    Map_get: 'mapGet',
    WeakMap_get: 'weakMapGet',
    string_codePointAt: 'stringCodePointAt',
    string_at: 'stringAt',
};
const JS_RUNTIME_CALL_METHOD_LIST = Object.keys(JS_RUNTIME_CALL_EXPRESSION_MAP).map((item) => item.split('_')[1]);
const GENERIC_TYPE_AS_PARAMETER_METHOD_MAP = [
    'uni.request',
    'JSON.parse',
    'JSON.parseArray',
    'JSON.parseObject',
];
function genericTypeToRuntimeType(tsUtils, type) {
    const ts = tsUtils.ts;
    const context = tsUtils.context;
    const factory = context.factory;
    if (ts.isArrayTypeNode(type)) {
        const { elementType } = type;
        return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier(IDENTIFIER.UTS_TYPE)), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier('Array'),
            factory.createArrayLiteralExpression([
                genericTypeToRuntimeType(tsUtils, elementType),
            ]),
            factory.createTrue(),
        ]);
    }
    if (ts.isTypeReferenceNode(type)) {
        const { typeName, typeArguments } = type;
        if (!ts.isIdentifier(typeName)) {
            const diag = ts.createDiagnosticForNode(typeName, UTSDiagnostics.Invalid_generic_type_which_can_not_be_constructed);
            context.addBindDiagnostic(diag);
            return factory.createIdentifier(IDENTIFIER.UTSJSONObject);
        }
        if (!typeArguments || typeArguments.length === 0) {
            return factory.createIdentifier(typeName.escapedText.toString());
        }
        return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(createUTSHelper(context), factory.createIdentifier(IDENTIFIER.UTS_TYPE)), factory.createIdentifier('withGenerics')), undefined, [
            factory.createIdentifier(typeName.escapedText.toString()),
            factory.createArrayLiteralExpression(typeArguments.map((item) => genericTypeToRuntimeType(tsUtils, item))),
            factory.createTrue(),
        ]);
    }
    const diag = ts.createDiagnosticForNode(type, UTSDiagnostics.Invalid_generic_type_which_can_not_be_constructed);
    context.addBindDiagnostic(diag);
    return factory.createIdentifier(IDENTIFIER.UTSJSONObject);
}
function parseJsRuntimeCallExpression(tsUtils, node) {
    const context = tsUtils.context;
    const factory = context.factory;
    const typeChecker = tsUtils.typeChecker;
    const ts = tsUtils.ts;
    const { expression, arguments: args } = node;
    if (!ts.isPropertyAccessExpression(expression)) {
        return node;
    }
    const { expression: object, name: prop } = expression;
    if (ts.isIdentifier(object) && ts.isIdentifier(prop)) {
        if (GENERIC_TYPE_AS_PARAMETER_METHOD_MAP.includes(`${object.escapedText}.${prop.escapedText}`)) {
            if (node.typeArguments &&
                node.typeArguments.length > 0 &&
                ts.isTypeReferenceNode(node.typeArguments[0]) &&
                ts.isIdentifier(node.typeArguments[0].typeName)) {
                return factory.updateCallExpression(node, expression, undefined, [
                    ...args,
                    genericTypeToRuntimeType(tsUtils, node.typeArguments[0]),
                ]);
            }
        }
    }
    if (!ts.isIdentifier(prop) ||
        !JS_RUNTIME_CALL_METHOD_LIST.includes(prop.escapedText.toString())) {
        return node;
    }
    if (object.pos < 0) {
        return node;
    }
    const objectType = typeChecker.getTypeAtLocation(object);
    // 注意需要处理Map<string, any> Array<number> WeakMap<Object, any>等场景
    let objectBaseTypeName = '';
    if (typeChecker.isArrayType(objectType)) {
        objectBaseTypeName = 'Array';
    }
    else if (
    // @ts-ignore
    typeChecker.isTypeAssignableTo(objectType, typeChecker.getStringType())) {
        objectBaseTypeName = 'string';
    }
    const symbolName = objectType.symbol?.escapedName.toString();
    if (symbolName === 'Map') {
        objectBaseTypeName = 'Map';
    }
    else if (symbolName === 'WeakMap') {
        objectBaseTypeName = 'WeakMap';
    }
    const propName = prop.escapedText;
    const helperName = JS_RUNTIME_CALL_EXPRESSION_MAP[`${objectBaseTypeName}_${propName}`];
    if (!helperName) {
        return node;
    }
    createUTSHelper(context);
    return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier(IDENTIFIER.UTS), factory.createIdentifier(helperName)), undefined, [object, ...args]);
}
const transformUTSRuntime = (ts, ls) => {
    return {
        before(context) {
            const program = ls.getProgram();
            const typeChecker = program.getTypeChecker();
            const tsUtils = createTsUtils(ts, typeChecker, context);
            const visitor = (node) => {
                if (ts.isIdentifier(node)) {
                    if (node.escapedText === IDENTIFIER.JSON) {
                        // 替换JSON对象
                        return transformJSON(tsUtils);
                    }
                    else if (node.escapedText === IDENTIFIER.UTSJSONObject) {
                        /**
                         * emitHelper自动引入的声明只能作为value使用不能作为type使用，因此值改为引入helper函数，类型改为全局类型
                         */
                        return createUTSJSONObjectHelper(context);
                    }
                }
                else if (ts.isBinaryExpression(node)) {
                    if (node.operatorToken.kind === ts.SyntaxKind.InstanceOfKeyword) {
                        node = transformInstanceof(tsUtils, node);
                    }
                }
                else if (ts.isCallExpression(node)) {
                    if (ts.isPropertyAccessExpression(node.expression)) {
                        node = parseJsRuntimeCallExpression(tsUtils, node);
                    }
                }
                node = ts.visitEachChild(node, visitor, context);
                return node;
            };
            return (node) => {
                return ts.visitNode(node, visitor);
            };
        },
    };
};

var transformers = [
    transformContext,
    transformVueDefineComponent,
    transformLifeCycleOptions,
    transformTypeAndInterface,
    transformObjectLiteral,
    transformComponentExtraProperty,
    transformClassImplements,
    transformTypedObjectLiteral,
    transformUTSRuntime,
    transformImportDeclaration,
    transformUndefinedToNull,
];

var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["Error"] = 0] = "Error";
    VerbosityLevel[VerbosityLevel["Warning"] = 1] = "Warning";
    VerbosityLevel[VerbosityLevel["Info"] = 2] = "Info";
    VerbosityLevel[VerbosityLevel["Debug"] = 3] = "Debug";
})(VerbosityLevel || (VerbosityLevel = {}));
function getText(message) {
    return typeof message === 'string' ? message : message();
}
/** cannot be used in options hook (which does not have this.warn and this.error), but can be in other hooks */
class RollupContext {
    constructor(verbosity, bail, context, prefix = '') {
        this.verbosity = verbosity;
        this.bail = bail;
        this.context = context;
        this.prefix = prefix;
    }
    warn(message) {
        if (this.verbosity < VerbosityLevel.Warning)
            return;
        this.context.warn(`${getText(message)}`);
    }
    error(message) {
        if (this.verbosity < VerbosityLevel.Error)
            return;
        if (this.bail) {
            if (typeof message === 'string' || typeof message === 'function') {
                this.context.error(`${getText(message)}`);
            }
            else {
                this.context.error(message);
            }
        }
        else {
            if (typeof message === 'string' || typeof message === 'function') {
                this.context.warn(`${getText(message)}`);
            }
            else {
                this.context.warn(message);
            }
        }
    }
    info(message) {
        if (this.verbosity < VerbosityLevel.Info)
            return;
        console.log(`${this.prefix}${getText(message)}`);
    }
    debug(message) {
        if (this.verbosity < VerbosityLevel.Debug)
            return;
        console.log(`${this.prefix}${getText(message)}`);
    }
}

const VUE_FILE_RE = /\.(u)?vue/;
let tsModule;
const utsFileNames = new Set();
function isUTSFile(fileName) {
    return (isVueFile(fileName) ||
        fileName.includes('.uts') ||
        utsFileNames.has(pluginutils.normalizePath(fileName)));
}
function isVueFile(fileName) {
    return VUE_FILE_RE.test(fileName);
}
function setTypescriptModule(override) {
    tsModule = override;
    // @ts-expect-error 判断是否已重写
    if (!tsModule.sys.__rewrited) {
        const { fileExists, readFile } = tsModule.sys;
        tsModule.sys.fileExists = (path) => {
            if (path.endsWith('.ts')) {
                if (fileExists(path.replace('.ts', '.uts'))) {
                    utsFileNames.add(pluginutils.normalizePath(path));
                    return true;
                }
            }
            return fileExists(path);
        };
        tsModule.sys.readFile = (path, encoding) => {
            if (path.endsWith('.ts')) {
                if (utsFileNames.has(pluginutils.normalizePath(path))) {
                    path = path.replace('.ts', '.uts');
                }
            }
            const content = readFile(path, encoding);
            if (!content) {
                return;
            }
            const replaceVueTypes = globalThis?.__utsHacker__
                ?.replaceVueTypes;
            return replaceVueTypes ? replaceVueTypes(path, content) : content;
        };
        // @ts-expect-error 设置重写标识
        tsModule.sys.__rewrited = true;
    }
}

class FormatHost {
    constructor() {
        this.getCanonicalFileName = path__namespace.normalize;
        this.getNewLine = () => tsModule.sys.newLine;
    }
    getCurrentDirectory() {
        return tsModule.sys.getCurrentDirectory();
    }
}
const formatHost = new FormatHost();

// function formatDiagnosticFormatted(
//   diagnostic: IDiagnostics,
//   codeFrame: string,
// ) {
//   let color
//   let category
//   switch (diagnostic.category) {
//     case tsModule.DiagnosticCategory.Message:
//       color = white
//       category = ''
//       break
//     case tsModule.DiagnosticCategory.Error:
//       color = red
//       category = 'error'
//       break
//     case tsModule.DiagnosticCategory.Warning:
//     default:
//       color = yellow
//       category = 'warning'
//       break
//   }
//   return `${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}
// ${codeFrame}`
// }
function formatDiagnostic(type, diagnostic, map) {
    const entry = {
        flatMessage: tsModule.flattenDiagnosticMessageText(diagnostic.messageText, formatHost.getNewLine()),
        formatted: tsModule.formatDiagnosticsWithColorAndContext([diagnostic], formatHost),
        category: diagnostic.category,
        code: diagnostic.code,
        type,
    };
    if (diagnostic.file && diagnostic.start !== undefined) {
        let { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
        if (map) {
            const mapped = map.originalPositionFor({
                line: line + 1,
                column: character,
                bias: sourceMapJs.SourceMapConsumer.LEAST_UPPER_BOUND,
            });
            if (mapped.line !== null) {
                if (mapped.source) {
                    const content = map.sourceContentFor(mapped.source);
                    if (content) {
                        const { line: endLine, character: endColumn } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start + (diagnostic.length || 0));
                        const end = map.originalPositionFor({
                            line: endLine + 1,
                            column: endColumn,
                        });
                        if (end.line !== null) {
                            entry.rollupError = createRollupError(diagnostic.file.fileName, entry.flatMessage, line + 1, // 不使用sourcemap之后的line，rollup会自动处理
                            character + 1, codeFrame.codeFrameColumns(content, {
                                start: {
                                    line: mapped.line,
                                    column: (mapped.column || 0) + 1,
                                },
                                end: {
                                    line: end.line,
                                    column: (end.column || 0) + 1,
                                },
                            }));
                        }
                    }
                }
                line = mapped.line;
            }
        }
        entry.fileLine = `${diagnostic.file.fileName}(${line + 1},${character + 1})`;
    }
    return entry;
}
function convertDiagnostic(type, data, map) {
    return data.map((diagnostic) => {
        return formatDiagnostic(type, diagnostic, map);
    });
}
function printDiagnostics(context, diagnostics, pretty = true) {
    diagnostics.forEach((diagnostic) => {
        let print;
        let color;
        let category;
        switch (diagnostic.category) {
            case tsModule.DiagnosticCategory.Message:
                print = context.info;
                color = safe.white;
                category = '';
                break;
            case tsModule.DiagnosticCategory.Error:
                print = context.error;
                color = safe.red;
                category = 'error';
                break;
            case tsModule.DiagnosticCategory.Warning:
            default:
                print = context.warn;
                color = safe.yellow;
                category = 'warning';
                break;
        }
        const type = diagnostic.type + ' ';
        if (pretty) {
            if (diagnostic.rollupError) {
                return print.call(context, diagnostic.rollupError);
            }
            return print.call(context, `${safe.enabled ? diagnostic.formatted : stripAnsi(diagnostic.formatted)}`);
        }
        if (diagnostic.fileLine !== undefined)
            return print.call(context, `${diagnostic.fileLine}: ${type}${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}`);
        return print.call(context, `${type}${category} TS${diagnostic.code}: ${color(diagnostic.flatMessage)}`);
    });
}
const regex = ansiRegex();
// 避免增加新的依赖包
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    }
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace(regex, '');
}
// https://github.com/chalk/ansi-regex/blob/main/index.js
function ansiRegex({ onlyFirst = false } = {}) {
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
function createRollupError(file, message, line, column, frame) {
    const rollupError = {
        id: file,
        message,
        frame,
        loc: {
            file,
            line,
            column,
        },
    };
    return rollupError;
}

function getOptionsOverrides({ useTsconfigDeclarationDir, cacheRoot }, preParsedTsconfig) {
    const overrides = {
        noEmitHelpers: false,
        importHelpers: true,
        noResolve: false,
        noEmit: false,
        noEmitOnError: false,
        inlineSourceMap: false,
        outDir: pluginutils.normalizePath(`${cacheRoot}/placeholder`),
        allowNonTsExtensions: true,
    };
    if (!preParsedTsconfig)
        return overrides;
    if (preParsedTsconfig.options.moduleResolution ===
        tsModule.ModuleResolutionKind.Classic)
        overrides.moduleResolution = tsModule.ModuleResolutionKind.Node10;
    if (preParsedTsconfig.options.module === undefined)
        overrides.module = tsModule.ModuleKind.ES2015;
    // only set declarationDir if useTsconfigDeclarationDir is enabled
    if (!useTsconfigDeclarationDir)
        overrides.declarationDir = undefined;
    // unsetting sourceRoot if sourceMap is not enabled (in case original tsconfig had inlineSourceMap set that is being unset and would cause TS5051)
    const sourceMap = preParsedTsconfig.options.sourceMap;
    if (!sourceMap)
        overrides.sourceRoot = undefined;
    return overrides;
}
function expandIncludeWithDirs(include, dirs) {
    const newDirs = [];
    dirs.forEach((root) => {
        if (include instanceof Array)
            include.forEach((x) => newDirs.push(pluginutils.normalizePath(path__namespace.join(root, x))));
        else
            newDirs.push(pluginutils.normalizePath(path__namespace.join(root, include)));
    });
    return newDirs;
}
function createFilter(context, pluginOptions, parsedConfig) {
    let included = pluginOptions.include;
    let excluded = pluginOptions.exclude;
    if (parsedConfig.options.rootDirs) {
        included = expandIncludeWithDirs(included, parsedConfig.options.rootDirs);
        excluded = expandIncludeWithDirs(excluded, parsedConfig.options.rootDirs);
    }
    if (parsedConfig.projectReferences) {
        included = expandIncludeWithDirs(included, parsedConfig.projectReferences.map((x) => x.path)).concat(included);
        excluded = expandIncludeWithDirs(excluded, parsedConfig.projectReferences.map((x) => x.path)).concat(excluded);
    }
    context.debug(() => `included:\n${JSON.stringify(included, undefined, 4)}`);
    context.debug(() => `excluded:\n${JSON.stringify(excluded, undefined, 4)}`);
    return pluginutils.createFilter(included, excluded, {
        resolve: parsedConfig.options.rootDir,
    });
}

class LanguageServiceHost {
    constructor(parsedConfig, transformers, cwd) {
        this.parsedConfig = parsedConfig;
        this.transformers = transformers;
        this.cwd = cwd;
        this.snapshots = {};
        this.versions = {};
        this.customParser = {};
        this.getScriptFileNames = () => Array.from(this.fileNames.values());
        this.getCompilationSettings = () => this.parsedConfig.options;
        this.getTypeRootsVersion = () => 0;
        this.getCurrentDirectory = () => this.cwd;
        this.useCaseSensitiveFileNames = () => tsModule.sys.useCaseSensitiveFileNames;
        this.getDefaultLibFileName = tsModule.getDefaultLibFilePath; // confusing naming: https://github.com/microsoft/TypeScript/issues/35318
        this.readDirectory = tsModule.sys.readDirectory;
        this.readFile = tsModule.sys.readFile;
        this.fileExists = tsModule.sys.fileExists;
        this.directoryExists = tsModule.sys.directoryExists;
        this.getDirectories = tsModule.sys.getDirectories;
        this.realpath = tsModule.sys.realpath; // this exists in the default implementation: https://github.com/microsoft/TypeScript/blob/ab2523bbe0352d4486f67b73473d2143ad64d03d/src/compiler/sys.ts#L1288
        this.trace = console.log;
        this.fileNames = new Set(parsedConfig.fileNames);
    }
    reset() {
        this.snapshots = {};
        this.versions = {};
    }
    setLanguageService(service) {
        // 补充辅助方法
        service.isUTSFile = isUTSFile;
        service.isVueFile = isVueFile;
        this.service = service;
        // // 初始化service时，初始化transformers，仅初始化一次
        if (!this.customTransformers) {
            this.initTransformers(this.transformers || []);
        }
    }
    setSnapshot(fileName, source) {
        fileName = pluginutils.normalizePath(fileName);
        const snapshot = tsModule.ScriptSnapshot.fromString(source);
        this.snapshots[fileName] = snapshot;
        this.versions[fileName] = (this.versions[fileName] || 0) + 1;
        this.fileNames.add(fileName);
        return snapshot;
    }
    getScriptSnapshot(fileName) {
        fileName = pluginutils.normalizePath(fileName);
        if (fileName in this.snapshots)
            return this.snapshots[fileName];
        const source = tsModule.sys.readFile(fileName);
        if (source)
            return this.setSnapshot(fileName, source);
        return undefined;
    }
    getScriptVersion(fileName) {
        fileName = pluginutils.normalizePath(fileName);
        return (this.versions[fileName] || 0).toString();
    }
    initTransformers(transformers) {
        if (this.service === undefined ||
            transformers === undefined ||
            this.transformers.length === 0)
            return undefined;
        const transformer = {
            before: [],
            after: [],
            afterDeclarations: [],
        };
        for (const creator of transformers) {
            const factory = creator(this.service);
            if (factory.parser) {
                this.customParser = factory.parser;
            }
            if (factory.before)
                transformer.before = transformer.before.concat(factory.before);
            if (factory.after)
                transformer.after = transformer.after.concat(factory.after);
            if (factory.afterDeclarations)
                transformer.afterDeclarations = transformer.afterDeclarations.concat(factory.afterDeclarations);
        }
        this.customTransformers = transformer;
        globalThis.__utsParser__ = this.customParser;
        return transformer;
    }
    getCustomTransformers() {
        return this.customTransformers;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setCompilerHost(host) {
        // TODO: implement
    }
}

function parseTsConfig(context, pluginOptions) {
    const fileName = tsModule.findConfigFile(pluginOptions.cwd, tsModule.sys.fileExists, pluginOptions.tsconfig);
    // if the value was provided, but no file, fail hard
    if (pluginOptions.tsconfig !== undefined && !fileName)
        context.error(`failed to open '${pluginOptions.tsconfig}'`);
    let loadedConfig = {};
    let baseDir = pluginOptions.cwd;
    let configFileName;
    let pretty = true;
    if (fileName) {
        const text = tsModule.sys.readFile(fileName); // readFile only returns undefined when the file doesn't exist, which we already checked above
        const result = tsModule.parseConfigFileTextToJson(fileName, text);
        pretty = result.config?.pretty ?? pretty;
        if (result.error !== undefined) {
            printDiagnostics(context, convertDiagnostic('config', [result.error]), pretty);
            context.error(`failed to parse '${fileName}'`);
        }
        loadedConfig = result.config;
        baseDir = path.dirname(fileName);
        configFileName = fileName;
    }
    const mergedConfig = {};
    ___namespace.merge(mergedConfig, pluginOptions.tsconfigDefaults, loadedConfig, pluginOptions.tsconfigOverride);
    const preParsedTsConfig = tsModule.parseJsonConfigFileContent(mergedConfig, tsModule.sys, baseDir, getOptionsOverrides(pluginOptions), configFileName);
    const compilerOptionsOverride = getOptionsOverrides(pluginOptions, preParsedTsConfig);
    const parsedTsConfig = tsModule.parseJsonConfigFileContent(mergedConfig, tsModule.sys, baseDir, compilerOptionsOverride, configFileName);
    const module = parsedTsConfig.options.module;
    if (module !== tsModule.ModuleKind.ES2015 &&
        module !== tsModule.ModuleKind.ES2020 &&
        module !== tsModule.ModuleKind.ES2022 &&
        module !== tsModule.ModuleKind.ESNext)
        context.error(`Incompatible tsconfig option. Module resolves to '${tsModule.ModuleKind[module]}'. This is incompatible with Rollup, please use 'module: "ES2015"', 'module: "ES2020"', 'module: "ES2022"', or 'module: "ESNext"'.`);
    printDiagnostics(context, convertDiagnostic('config', parsedTsConfig.errors), pretty);
    context.debug(`built-in options overrides: ${JSON.stringify(compilerOptionsOverride, undefined, 4)}`);
    context.debug(`parsed tsconfig: ${JSON.stringify(parsedTsConfig, undefined, 4)}`);
    return { parsedTsConfig, fileName };
}

/**
 * Saves data in new cache folder or reads it from old one.
 * Avoids perpetually growing cache and situations when things need to consider changed and then reverted data to be changed.
 */
class RollingCache {
    /** @param cacheRoot: root folder for the cache */
    constructor(cacheRoot) {
        this.cacheRoot = cacheRoot;
        this.rolled = false;
        this.oldCacheRoot = `${this.cacheRoot}/cache`;
        this.newCacheRoot = `${this.cacheRoot}/cache_`;
        fs.emptyDirSync(this.newCacheRoot);
    }
    /** @returns true if name exists in either old cache or new cache */
    exists(name) {
        if (this.rolled)
            return false;
        if (fs$1.existsSync(`${this.newCacheRoot}/${name}`))
            return true;
        return fs$1.existsSync(`${this.oldCacheRoot}/${name}`);
    }
    path(name) {
        return `${this.oldCacheRoot}/${name}`;
    }
    /** @returns true if old cache contains all names and nothing more */
    match(names) {
        if (this.rolled)
            return false;
        if (!fs$1.existsSync(this.oldCacheRoot))
            return names.length === 0; // empty folder matches
        return ___namespace.isEqual(fs$1.readdirSync(this.oldCacheRoot).sort(), names.sort());
    }
    /** @returns data for name, must exist in either old cache or new cache */
    read(name) {
        if (fs$1.existsSync(`${this.newCacheRoot}/${name}`))
            return fs.readJsonSync(`${this.newCacheRoot}/${name}`, {
                encoding: 'utf8',
                throws: false,
            });
        return fs.readJsonSync(`${this.oldCacheRoot}/${name}`, {
            encoding: 'utf8',
            throws: false,
        });
    }
    write(name, data) {
        if (this.rolled)
            return;
        if (data === undefined)
            return;
        fs.writeJsonSync(`${this.newCacheRoot}/${name}`, data);
    }
    touch(name) {
        if (this.rolled)
            return;
        fs.ensureFileSync(`${this.newCacheRoot}/${name}`);
    }
    /** clears old cache and moves new in its place */
    roll() {
        if (this.rolled)
            return;
        this.rolled = true;
        fs.removeSync(this.oldCacheRoot);
        if (fs$1.existsSync(this.newCacheRoot)) {
            fs$1.renameSync(this.newCacheRoot, this.oldCacheRoot);
        }
    }
}

function convertEmitOutput(output, references) {
    const out = { code: '', references };
    output.outputFiles.forEach((e) => {
        if (e.name.endsWith('.d.ts'))
            out.dts = e;
        else if (e.name.endsWith('.d.ts.map'))
            out.dtsmap = e;
        else if (e.name.endsWith('.map'))
            out.map = e.text;
        else
            out.code = e.text;
    });
    return out;
}
function getAllReferences(importer, snapshot, options) {
    if (!snapshot)
        return [];
    const info = tsModule.preProcessFile(snapshot.getText(0, snapshot.getLength()), true, true);
    return ___namespace.compact(info.referencedFiles.concat(info.importedFiles).map((reference) => {
        const resolved = tsModule.nodeModuleNameResolver(reference.fileName, importer, options, tsModule.sys);
        return resolved.resolvedModule?.resolvedFileName;
    }));
}
class TsCache {
    constructor(noCache, runClean, hashIgnoreUnknown, host, cacheRoot, options, rollupConfig, rootFilenames, context) {
        this.noCache = noCache;
        this.host = host;
        this.cacheRoot = cacheRoot;
        this.options = options;
        this.rollupConfig = rollupConfig;
        this.context = context;
        this.cacheVersion = '9';
        this.cachePrefix = 'uts_';
        this.ambientTypesDirty = false;
        // fixed by xxxxxx add const
        this.hashOptions = { algorithm: 'sha1', ignoreUnknown: false };
        this.dependencyTree = new graphlib.Graph({ directed: true });
        this.dependencyTree.setDefaultNodeLabel(() => ({ dirty: false }));
        if (runClean)
            this.clean();
        if (noCache)
            return;
        this.hashOptions.ignoreUnknown = hashIgnoreUnknown;
        this.cacheDir = `${this.cacheRoot}/${this.cachePrefix}${objHash({
            version: this.cacheVersion,
            rootFilenames,
            options: this.options,
            rollupConfig: this.rollupConfig,
            tsVersion: tsModule.version,
        }, this.hashOptions)}`;
        this.init();
        const automaticTypes = tsModule
            .getAutomaticTypeDirectiveNames(options, tsModule.sys)
            .map((entry) => tsModule.resolveTypeReferenceDirective(entry, undefined, options, tsModule.sys))
            .filter((entry) => entry.resolvedTypeReferenceDirective?.resolvedFileName)
            .map((entry) => entry.resolvedTypeReferenceDirective.resolvedFileName);
        this.ambientTypes = rootFilenames
            .filter((file) => file.endsWith('.d.ts'))
            .concat(automaticTypes)
            .map((id) => ({ id, snapshot: this.host.getScriptSnapshot(id) }));
        this.checkAmbientTypes();
    }
    clean() {
        if (!fs__namespace.pathExistsSync(this.cacheRoot))
            return;
        const entries = fs__namespace.readdirSync(this.cacheRoot);
        entries.forEach((e) => {
            const dir = `${this.cacheRoot}/${e}`;
            /* istanbul ignore if -- this is a safety check, but shouldn't happen when using a dedicated cache dir */
            if (!e.startsWith(this.cachePrefix)) {
                this.context.debug(`skipping cleaning '${dir}' as it does not have prefix '${this.cachePrefix}'`);
                return;
            }
            /* istanbul ignore if -- this is a safety check, but should never happen in normal usage */
            if (!fs__namespace.statSync(dir).isDirectory) {
                this.context.debug(`skipping cleaning '${dir}' as it is not a directory`);
                return;
            }
            this.context.info(safe.blue(`cleaning cache: ${dir}`));
            fs__namespace.removeSync(`${dir}`);
        });
    }
    setDependency(importee, importer) {
        // importee -> importer
        this.context.debug(`${safe.blue('dependency')} '${importee}'`);
        this.context.debug(`    imported by '${importer}'`);
        this.dependencyTree.setEdge(importer, importee);
    }
    walkTree(cb) {
        if (graphlib.alg.isAcyclic(this.dependencyTree))
            return graphlib.alg.topsort(this.dependencyTree).forEach((id) => cb(id));
        this.context.info(safe.yellow('import tree has cycles'));
        this.dependencyTree.nodes().forEach((id) => cb(id));
    }
    done() {
        if (this.noCache)
            return;
        this.context.info(safe.blue('rolling caches'));
        this.codeCache.roll();
        this.semanticDiagnosticsCache.roll();
        this.syntacticDiagnosticsCache.roll();
        this.typesCache.roll();
    }
    getCompiled(id, snapshot, transform) {
        this.context.info(`${safe.blue('transpiling')} '${id}'`);
        // if !isolatedModules, compiled JS code can change if its imports do (e.g. enums). also, declarations can change based on imports as well
        return this.getCached(this.codeCache, id, snapshot, Boolean(!this.options.isolatedModules || this.options.declaration), transform);
    }
    getSyntacticDiagnostics(id, snapshot, check, map) {
        return this.getDiagnostics('syntax', this.syntacticDiagnosticsCache, id, snapshot, check, map);
    }
    getSemanticDiagnostics(id, snapshot, check, map) {
        return this.getDiagnostics('semantic', this.semanticDiagnosticsCache, id, snapshot, check, map);
    }
    checkAmbientTypes() {
        this.context.debug(safe.blue('Ambient types:'));
        const typeHashes = this.ambientTypes
            .filter((snapshot) => snapshot.snapshot !== undefined)
            .map((snapshot) => {
            this.context.debug(`    ${snapshot.id}`);
            return this.createHash(snapshot.id, snapshot.snapshot);
        });
        // types dirty if any d.ts changed, added or removed
        this.ambientTypesDirty = !this.typesCache.match(typeHashes);
        if (this.ambientTypesDirty)
            this.context.info(safe.yellow('ambient types changed, redoing all semantic diagnostics'));
        typeHashes.forEach(this.typesCache.touch, this.typesCache);
    }
    getDiagnostics(type, cache, id, snapshot, check, map) {
        // don't need to check imports for syntactic diagnostics (per https://github.com/microsoft/TypeScript/wiki/Using-the-Language-Service-API#design-goals)
        return this.getCached(cache, id, snapshot, type === 'semantic', () => convertDiagnostic(type, check(), map));
    }
    getCached(cache, id, snapshot, checkImports, convert) {
        if (this.noCache)
            return convert();
        const hash = this.createHash(id, snapshot);
        this.context.debug(`    cache: '${cache.path(hash)}'`);
        if (cache.exists(hash) && !this.isDirty(id, checkImports)) {
            this.context.debug(safe.green('    cache hit'));
            const data = cache.read(hash);
            if (data) {
                cache.write(hash, data);
                return data;
            } /* istanbul ignore next -- should only happen when corrupted cache */
            else
                this.context.warn(safe.yellow('    cache broken, discarding'));
        }
        this.context.debug(safe.yellow('    cache miss'));
        const convertedData = convert();
        cache.write(hash, convertedData);
        this.markAsDirty(id);
        return convertedData;
    }
    init() {
        this.codeCache = new RollingCache(`${this.cacheDir}/code`);
        this.typesCache = new RollingCache(`${this.cacheDir}/types`);
        this.syntacticDiagnosticsCache = new RollingCache(`${this.cacheDir}/syntacticDiagnostics`);
        this.semanticDiagnosticsCache = new RollingCache(`${this.cacheDir}/semanticDiagnostics`);
    }
    markAsDirty(id) {
        this.dependencyTree.setNode(id, { dirty: true });
    }
    /** @returns true if node, any of its imports, or any ambient types changed */
    isDirty(id, checkImports) {
        const label = this.dependencyTree.node(id);
        if (!label)
            return false;
        if (!checkImports || label.dirty)
            return label.dirty;
        if (this.ambientTypesDirty)
            return true;
        const dependencies = graphlib.alg.dijkstra(this.dependencyTree, id);
        return Object.keys(dependencies).some((node) => {
            const dependency = dependencies[node];
            if (!node || dependency.distance === Infinity)
                return false;
            const l = this.dependencyTree.node(node);
            const dirty = l === undefined ? true : l.dirty;
            if (dirty)
                this.context.debug(`    import changed: ${node}`);
            return dirty;
        });
    }
    /** @returns an FS-safe hash string for use as a path to the cached content */
    createHash(id, snapshot) {
        const data = snapshot.getText(0, snapshot.getLength());
        return objHash({ data, id }, this.hashOptions);
    }
}

// The injected id for helpers.
const TSLIB = 'tslib';
const TSLIB_VIRTUAL = '\0tslib.js';

// these use globals during testing and are substituted by rollup-plugin-re during builds
const TS_VERSION_RANGE = ">=5.0.0";
const ROLLUP_VERSION_RANGE = ">=3.0.0";
const ROLLUP_PLUGIN_UTS_VERSION = "1.0.0";
const typescript = (options) => {
    let watchMode = false;
    let supportsThisLoad = false;
    let generateRound = 0;
    let rollupOptions;
    let context;
    let filter;
    let parsedConfig;
    let tsConfigPath;
    let servicesHost;
    let service;
    let documentRegistry; // keep the same DocumentRegistry between watch cycles
    let cache;
    let noErrors = true;
    let transformedFiles;
    const declarations = {};
    const checkedFiles = new Set();
    const getDiagnostics = (id, snapshot, map) => {
        return cache
            .getSyntacticDiagnostics(id, snapshot, () => {
            return service.getSyntacticDiagnostics(id);
        }, map)
            .concat(cache.getSemanticDiagnostics(id, snapshot, () => {
            return service.getSemanticDiagnostics(id);
        }, map));
    };
    const typecheckFile = (id, snapshot, tcContext, map) => {
        if (!snapshot)
            return;
        id = pluginutils.normalizePath(id);
        checkedFiles.add(id); // must come before print, as that could bail
        const diagnostics = getDiagnostics(id, snapshot, map);
        printDiagnostics(tcContext, diagnostics, parsedConfig.options.pretty !== false);
        if (diagnostics.length > 0)
            noErrors = false;
    };
    const addDeclaration = (id, result) => {
        if (!result.dts)
            return;
        const key = pluginutils.normalizePath(id);
        declarations[key] = { type: result.dts, map: result.dtsmap };
        context.debug(() => `${safe.blue('generated declarations')} for '${key}'`);
    };
    /** common resolution check -- only resolve files that aren't declarations and pass `filter` */
    const shouldResolve = (id) => {
        if (id.endsWith('.d.ts') || id.endsWith('.d.cts') || id.endsWith('.d.mts'))
            return false;
        if (!filter(id))
            return false;
        return true;
    };
    /** to be called at the end of Rollup's build phase, before output generation */
    const buildDone = () => {
        if (!watchMode && !noErrors)
            context.info(safe.yellow('there were errors or warnings.'));
        cache?.done(); // if there's an initialization error in `buildStart`, such as a `tsconfig` error, the cache may not exist yet
    };
    const pluginOptions = Object.assign({}, {
        check: true,
        verbosity: VerbosityLevel.Warning,
        clean: false,
        cacheRoot: findCacheDir({ name: 'rollup-plugin-uts' }),
        include: ['*.ts+(|x)', '**/*.ts+(|x)', '**/*.cts', '**/*.mts'],
        exclude: ['*.d.ts', '**/*.d.ts', '**/*.d.cts', '**/*.d.mts'],
        abortOnError: true,
        rollupCommonJSResolveHack: false,
        tsconfig: undefined,
        useTsconfigDeclarationDir: false,
        tsconfigOverride: {},
        transformers: [],
        tsconfigDefaults: {},
        objectHashIgnoreUnknownHack: false,
        cwd: process.cwd(),
    }, options);
    if (!pluginOptions.typescript) {
        pluginOptions.typescript = require('typescript');
    }
    setTypescriptModule(pluginOptions.typescript);
    // eslint-disable-next-line prefer-const
    documentRegistry = tsModule.createDocumentRegistry();
    const self = {
        name: 'uts',
        options(config) {
            rollupOptions = { ...config };
            return config;
        },
        buildStart() {
            context = new RollupContext(pluginOptions.verbosity, pluginOptions.abortOnError, this, 'uts: ');
            watchMode = process.env.ROLLUP_WATCH === 'true' || !!this.meta.watchMode // meta.watchMode was added in 2.14.0 to capture watch via Rollup API (i.e. no env var) (c.f. https://github.com/rollup/rollup/blob/master/CHANGELOG.md#2140)
            ;
            ({ parsedTsConfig: parsedConfig, fileName: tsConfigPath } =
                parseTsConfig(context, pluginOptions));
            // print out all versions and configurations
            context.info(`typescript version: ${tsModule.version}`);
            context.info(`tslib version: ${pluginOptions.utsOptions.tslibVersion}`);
            context.info(`rollup version: ${this.meta.rollupVersion}`);
            if (!semver.satisfies(tsModule.version, TS_VERSION_RANGE, {
                includePrerelease: true,
            }))
                context.error(`Installed TypeScript version '${tsModule.version}' is outside of supported range '${TS_VERSION_RANGE}'`);
            if (!semver.satisfies(this.meta.rollupVersion, ROLLUP_VERSION_RANGE, {
                includePrerelease: true,
            }))
                context.error(`Installed Rollup version '${this.meta.rollupVersion}' is outside of supported range '${ROLLUP_VERSION_RANGE}'`);
            supportsThisLoad = semver.satisfies(this.meta.rollupVersion, '>=2.60.0', {
                includePrerelease: true,
            }); // this.load is 2.60.0+ only (c.f. https://github.com/rollup/rollup/blob/master/CHANGELOG.md#2600)
            if (!supportsThisLoad)
                context.warn(() => `${safe.yellow("You are using a Rollup version '<2.60.0'")}. This may result in type-only files being ignored.`);
            context.info(`rollup-plugin-uts version: ${ROLLUP_PLUGIN_UTS_VERSION}`);
            context.debug(() => `plugin options:\n${JSON.stringify(pluginOptions, (key, value) => key === 'typescript'
                ? `version ${value.version}`
                : value, 4)}`);
            context.debug(() => `rollup config:\n${JSON.stringify(rollupOptions, undefined, 4)}`);
            context.debug(() => `tsconfig path: ${tsConfigPath}`);
            if (pluginOptions.objectHashIgnoreUnknownHack)
                context.warn(() => `${safe.yellow("You are using 'objectHashIgnoreUnknownHack' option")}. If you enabled it because of async functions, try disabling it now.`);
            if (pluginOptions.rollupCommonJSResolveHack)
                context.warn(() => `${safe.yellow("You are using 'rollupCommonJSResolveHack' option")}. This is no longer needed, try disabling it now.`);
            if (watchMode)
                context.info(`running in watch mode`);
            filter = createFilter(context, pluginOptions, parsedConfig);
            servicesHost = new LanguageServiceHost(parsedConfig, pluginOptions.transformers, pluginOptions.cwd);
            service = tsModule.createLanguageService(servicesHost, documentRegistry);
            servicesHost.setLanguageService(service);
            const runClean = pluginOptions.clean;
            const noCache = pluginOptions.clean || watchMode;
            cache = new TsCache(noCache, runClean, pluginOptions.objectHashIgnoreUnknownHack, servicesHost, pluginOptions.cacheRoot, parsedConfig.options, rollupOptions, parsedConfig.fileNames, context);
            // reset transformedFiles Set on each watch cycle
            transformedFiles = new Set();
            // printing compiler option errors
            if (pluginOptions.check) {
                const diagnostics = convertDiagnostic('options', service.getCompilerOptionsDiagnostics());
                printDiagnostics(context, diagnostics, parsedConfig.options.pretty !== false);
                if (diagnostics.length > 0)
                    noErrors = false;
            }
        },
        watchChange(id) {
            const key = pluginutils.normalizePath(id);
            delete declarations[key];
            checkedFiles.delete(key);
        },
        resolveId(importee, importer) {
            if (importee === TSLIB)
                return TSLIB_VIRTUAL;
            if (!importer)
                return;
            importer = pluginutils.normalizePath(importer);
            // TODO: use module resolution cache
            const result = tsModule.nodeModuleNameResolver(importee, importer, parsedConfig.options, tsModule.sys);
            let resolved = result.resolvedModule?.resolvedFileName;
            if (!resolved)
                return;
            if (utsFileNames.has(pluginutils.normalizePath(resolved))) {
                resolved = resolved.replace('.ts', '.uts');
            }
            if (!shouldResolve(resolved))
                return;
            cache.setDependency(resolved, importer);
            context.debug(() => `${safe.blue('resolving')} '${importee}' imported by '${importer}'`);
            context.debug(() => `    to '${resolved}'`);
            return path.normalize(resolved); // use host OS separators to fix Windows issue: https://github.com/ezolenko/rollup-plugin-typescript2/pull/251
        },
        load(id) {
            if (id === TSLIB_VIRTUAL)
                return pluginOptions.utsOptions.tslibSource;
            return null;
        },
        async transform(code, id) {
            transformedFiles.add(id); // note: this does not need normalization as we only compare Rollup <-> Rollup, and not Rollup <-> TS
            if (!filter(id))
                return undefined;
            const snapshot = servicesHost.setSnapshot(id, code);
            // getting compiled file from cache or from ts
            const result = cache.getCompiled(id, snapshot, () => {
                let output;
                // 输出uts (带类型)
                if (pluginOptions.utsOptions.emitType === 'uts') {
                    const sourceFile = service.getProgram()?.getSourceFile(id);
                    const outputFiles = [];
                    if (!sourceFile) {
                        this.error(new Error(`Could not find source file: '${id}'.`));
                    }
                    else {
                        const printer = tsModule.createPrinter({});
                        const result = printer.printSourceFile(sourceFile, {
                            host: formatHost,
                            map: {
                                file: pluginutils.normalizePath(path.relative(pluginOptions.utsOptions.inputDir ?? '', id)),
                                sourceRoot: '',
                                sourcesDirectoryPath: pluginOptions.utsOptions.inputDir ?? '',
                            },
                        });
                        if (result.code) {
                            outputFiles.push({
                                name: '',
                                writeByteOrderMark: false,
                                text: result.code,
                            });
                        }
                        if (result.map) {
                            outputFiles.push({
                                name: '.map',
                                writeByteOrderMark: false,
                                text: result.map,
                            });
                        }
                    }
                    output = {
                        outputFiles,
                        emitSkipped: false,
                    };
                }
                else {
                    // 输出 js
                    output = service.getEmitOutput(id);
                }
                if (output.emitSkipped) {
                    noErrors = false;
                    // always checking on fatal errors, even if options.check is set to false
                    typecheckFile(id, snapshot, context, options?.abortOnError
                        ? undefined
                        : new sourceMapJs.SourceMapConsumer(this.getCombinedSourcemap()));
                    // since no output was generated, aborting compilation
                    this.error(safe.red(`Emit skipped for '${id}'. See https://github.com/microsoft/TypeScript/issues/49790 for potential reasons why this may occur`));
                }
                const references = getAllReferences(id, snapshot, parsedConfig.options);
                return convertEmitOutput(output, references);
            });
            if (pluginOptions.check)
                typecheckFile(id, snapshot, context, new sourceMapJs.SourceMapConsumer(this.getCombinedSourcemap()));
            if (!result)
                return undefined;
            if (watchMode && result.references) {
                if (tsConfigPath)
                    this.addWatchFile(tsConfigPath);
                result.references.map(this.addWatchFile, this);
                context.debug(() => `${safe.green('    watching')}: ${result.references.join('\nuts:               ')}`);
            }
            addDeclaration(id, result);
            // handle all type-only imports by resolving + loading all of TS's references
            // Rollup can't see these otherwise, because they are "emit-less" and produce no JS
            if (result.references && supportsThisLoad) {
                for (const ref of result.references) {
                    // pre-emptively filter out files that we don't resolve ourselves (e.g. declarations). don't add new files to Rollup's pipeline if we can't resolve them
                    if (!shouldResolve(ref))
                        continue;
                    const module = await this.resolve(ref, id);
                    if (!module || transformedFiles.has(module.id))
                        // check for circular references (per https://rollupjs.org/guide/en/#thisload)
                        continue;
                    // wait for all to be loaded (otherwise, as this is async, some may end up only loading after `generateBundle`)
                    await this.load({ id: module.id });
                }
            }
            // if a user sets this compilerOption, they probably want another plugin (e.g. Babel, ESBuild) to transform their TS instead, while rpt2 just type-checks and/or outputs declarations
            // note that result.code is non-existent if emitDeclarationOnly per https://github.com/ezolenko/rollup-plugin-typescript2/issues/268
            if (parsedConfig.options.emitDeclarationOnly) {
                context.debug(() => `${safe.blue('emitDeclarationOnly')} enabled, not transforming TS`);
                return undefined;
            }
            const transformResult = {
                code: result.code,
                map: { mappings: '' },
            };
            if (result.map) {
                pluginOptions.sourceMapCallback?.(id, result.map);
                const map = JSON.parse(result.map);
                if (map.sourceRoot) {
                    map.sources = map.sources.map((source) => {
                        if (!path.isAbsolute(source)) {
                            return map.sourceRoot + source;
                        }
                        return source;
                    });
                }
                transformResult.map = map;
            }
            return transformResult;
        },
        buildEnd(err) {
            generateRound = 0; // in watch mode, buildEnd resets generate count just before generateBundle for each output
            if (err) {
                buildDone();
                // workaround: err.stack contains err.message and Rollup prints both, causing duplication, so split out the stack itself if it exists (c.f. https://github.com/ezolenko/rollup-plugin-typescript2/issues/103#issuecomment-1172820658)
                const stackOnly = err.stack?.split(err.message)[1];
                if (stackOnly)
                    this.error({
                        ...err,
                        message: err.message,
                        stack: stackOnly,
                    });
                else
                    this.error(err);
            }
            if (!pluginOptions.check)
                return buildDone();
            // walkTree once on each cycle when in watch mode
            if (watchMode) {
                cache.walkTree((id) => {
                    if (!filter(id))
                        return;
                    const snapshot = servicesHost.getScriptSnapshot(id);
                    typecheckFile(id, snapshot, context);
                });
            }
            // type-check missed files as well
            parsedConfig.fileNames.forEach((name) => {
                const key = pluginutils.normalizePath(name);
                if (checkedFiles.has(key) || !filter(key))
                    // don't duplicate if it's already been checked
                    return;
                context.debug(() => `type-checking missed '${key}'`);
                const snapshot = servicesHost.getScriptSnapshot(key);
                typecheckFile(key, snapshot, context);
            });
            buildDone();
        },
        generateBundle(_output) {
            context.debug(() => `generating target ${generateRound + 1}`);
            generateRound++;
            if (!parsedConfig.options.declaration)
                return;
            parsedConfig.fileNames.forEach((name) => {
                const key = pluginutils.normalizePath(name);
                if (key in declarations || !filter(key))
                    return;
                context.debug(() => `generating missed declarations for '${key}'`);
                const out = convertEmitOutput(service.getEmitOutput(key, true));
                addDeclaration(key, out);
            });
            const emitDeclaration = (key, extension, entry) => {
                if (!entry)
                    return;
                let fileName = entry.name;
                if (fileName.includes('?'))
                    // HACK for rollup-plugin-vue, it creates virtual modules in form 'file.vue?rollup-plugin-vue=script.ts'
                    fileName = fileName.split('?', 1) + extension;
                // If 'useTsconfigDeclarationDir' is in plugin options, directly write to 'declarationDir'.
                // This may not be under Rollup's output directory, and thus can't be emitted as an asset.
                if (pluginOptions.useTsconfigDeclarationDir) {
                    context.debug(() => `${safe.blue('emitting declarations')} for '${key}' to '${fileName}'`);
                    tsModule.sys.writeFile(fileName, entry.text, entry.writeByteOrderMark);
                    return;
                }
                // don't mutate the entry because generateBundle gets called multiple times
                let entryText = entry.text;
                const cachePlaceholder = `${pluginOptions.cacheRoot}/placeholder`;
                // modify declaration map sources to correct relative path (only if outputting)
                if (extension === '.d.ts.map' && (_output?.file || _output?.dir)) {
                    const declarationDir = (_output.file ? path.dirname(_output.file) : _output.dir);
                    const parsedText = JSON.parse(entryText);
                    // invert back to absolute, then make relative to declarationDir
                    parsedText.sources = parsedText.sources.map((source) => {
                        const absolutePath = path.resolve(cachePlaceholder, source);
                        return pluginutils.normalizePath(path.relative(declarationDir, absolutePath));
                    });
                    entryText = JSON.stringify(parsedText);
                }
                const relativePath = pluginutils.normalizePath(path.relative(cachePlaceholder, fileName));
                context.debug(() => `${safe.blue('emitting declarations')} for '${key}' to '${relativePath}'`);
                this.emitFile({
                    type: 'asset',
                    source: entryText,
                    fileName: relativePath,
                });
            };
            Object.keys(declarations).forEach((key) => {
                const { type, map } = declarations[key];
                emitDeclaration(key, '.d.ts', type);
                emitDeclaration(key, '.d.ts.map', map);
            });
        },
    };
    return self;
};

const __url = url.pathToFileURL(__filename).href;
const __dirname$1 = path.dirname(url.fileURLToPath(__url));
const require$1 = module$1.createRequire(__url);
function uts2js({ inputDir, version, ...options }) {
    const include = options.include ?? [
        '**/*.uts',
        '**/*.ts',
        // '**/*.uvue',
        // '**/*.vue',
    ];
    const ts = options.typescript ?? require$1('typescript');
    const rputsOptions = {
        ...options,
        include,
        typescript: ts,
        transformers: [parseTransformer(ts, transformers)],
        utsOptions: {
            tslibVersion: version,
            tslibSource: fs$1.readFileSync(path.resolve(__dirname$1, '../lib/runtime/index.js'), 'utf8'),
        },
    };
    if (!rputsOptions.tsconfigOverride) {
        rputsOptions.tsconfigOverride = {
            compilerOptions: {},
        };
    }
    if (!rputsOptions.tsconfigOverride.compilerOptions) {
        rputsOptions.tsconfigOverride.compilerOptions = {};
    }
    Object.assign(rputsOptions.tsconfigOverride.compilerOptions, {
        baseUrl: path.basename(inputDir) === 'src' ? path.dirname(inputDir) : inputDir,
        target: 'ESNext',
        moduleResolution: 'Bundler',
        importHelpers: true,
        mapRoot: inputDir,
    });
    return [typescript(rputsOptions)];
}

exports.uts2js = uts2js;
